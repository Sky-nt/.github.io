<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Expression学习笔记之表达式与表达式树的基本结构</title>
    <link href="/2022/10/13/CSharp/Expression%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2022/10/13/CSharp/Expression%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="一个美丽的邂逅"><a href="#一个美丽的邂逅" class="headerlink" title="一个美丽的邂逅"></a>一个美丽的邂逅</h2><p>昨天心血来潮，想着用了很久的HangFire这个任务调度组件，却从来没有研究过其源码，所以我就想着看一下Hangfire的源码，然后当我看到Hangfire源码中 AspNetShutdownDetector(Asp.Net服务停止检测器)这个类的源码的时候，看到其实现方式中，有两个私有的方法，看起名称是用于创建或者获取某个类中的静态字段和非静态字段的，但是看其实现则是通过表达式树进行反射查找。代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Func</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">CreateGetStaticFieldDelegate</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">FieldInfo fieldInfo</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> fieldExp = Expression.Field(<span class="hljs-literal">null</span>, fieldInfo);<br>    <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;T&gt;&gt;(fieldExp).Compile();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title">Func</span>&lt;<span class="hljs-title">object</span>, <span class="hljs-title">T</span>&gt; <span class="hljs-title">CreateGetFieldDelegate</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">FieldInfo fieldInfo, Type type</span>)</span><br>&#123;<br>    <span class="hljs-keyword">var</span> instExp = Expression.Parameter(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">object</span>));<br>    <span class="hljs-keyword">var</span> convExp = Expression.Convert(instExp, type);<br>    <span class="hljs-keyword">var</span> fieldExp = Expression.Field(convExp, fieldInfo);<br>    <span class="hljs-keyword">return</span> Expression.Lambda&lt;Func&lt;<span class="hljs-built_in">object</span>, T&gt;&gt;(fieldExp, instExp).Compile();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>事情突然就变得有趣起来了，因为本人是个小菜鸡，日常来说只会通过Expression来进行数据库条件查询这种基础操作，还真没有考虑过更深层次的操作，但是，人菜瘾大，又菜又爱研究，所以一下就被这个操作给吸引住了，然后越看越感兴趣，之前居然没想到表达式树居然还能进行反射操作，所以二话不说就抛弃了Hangfire的源码（毕竟得先搞懂这种操作的实现原理才能明白人家写这个用意嘛）开始专心研究起表达式树来了。</p><h2 id="初识Expression"><a href="#初识Expression" class="headerlink" title="初识Expression"></a>初识Expression</h2><p>首先，我选择先来了解一下Expression的概念及相关的方法（说实话以前真没有认真研究过，实在是惭愧）, 而了解这个玩意的最好地方就是微软官方给出的<a href="https://https//learn.microsoft.com/zh-cn/dotnet/api/system.linq.expressions.expression?view=net-6.0">文档</a>，文档原文：Expression是一个抽象类，他主要是表示表达式树节点的类派生的基类。而其派生的类如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//表示具有二进制运算符的表达式</span><br>System.Linq.Expressions.BinaryExpression <br><span class="hljs-comment">//表示包含一个表达式序列的块，表达式中可定义变量。</span><br>System.Linq.Expressions.BlockExpression<br><span class="hljs-comment">//表示具有条件运算符的表达式。</span><br>System.Linq.Expressions.ConditionalExpression <br><span class="hljs-comment">//表示具有常数值的表达式</span><br>System.Linq.Expressions.ConstantExpression <br><span class="hljs-comment">//发出或清除调试信息的序列点。 这使调试器能够在调试时突出显示正确的源代码。</span><br>System.Linq.Expressions.DebugInfoExpression <br><span class="hljs-comment">//表示一个类型或空表达式的默认值。</span><br>System.Linq.Expressions.DefaultExpression<br><span class="hljs-comment">//表示一个动态操作</span><br>System.Linq.Expressions.DynamicExpression<br><span class="hljs-comment">//表示无条件跳转。 这包括返回语句，break 和 continue 语句以及其他跳转。</span><br>System.Linq.Expressions.GotoExpression<br><span class="hljs-comment">//表示对一个属性或数组进行索引。</span><br>System.Linq.Expressions.IndexExpression<br><span class="hljs-comment">//表示一个将委托或 Lambda 表达式应用到一个自变量表达式列表的表达式。</span><br>System.Linq.Expressions.InvocationExpression <br><span class="hljs-comment">//表示一个标签，可以将该标签放置在任何 Expression 上下文中。</span><br><span class="hljs-comment">//如果已跳转到该标签，则它将获取由对应的 GotoExpression 提供的值。 </span><br><span class="hljs-comment">//否则，它接收 DefaultValue 中的值。 </span><br><span class="hljs-comment">//如果 Type 等于 System.Void，则不应提供值。</span><br>System.Linq.Expressions.LabelExpression <br><span class="hljs-comment">//介绍 lambda 表达式。 它捕获一个类似于 .NET 方法主体的代码块。</span><br>System.Linq.Expressions.LambdaExpression<br><span class="hljs-comment">//表示具有集合初始值设定项的构造函数调用。</span><br>System.Linq.Expressions.ListInitExpression<br><span class="hljs-comment">//表示无限循环。 可通过“中断”退出该循环。</span><br>System.Linq.Expressions.LoopExpression<br><span class="hljs-comment">//表示访问字段或属性。</span><br>System.Linq.Expressions.MemberExpression<br><span class="hljs-comment">//表示调用构造函数并初始化新对象的一个或多个成员。</span><br>System.Linq.Expressions.MemberInitExpression<br><span class="hljs-comment">//表示对静态方法或实例方法的调用。</span><br>System.Linq.Expressions.MethodCallExpression<br><span class="hljs-comment">//表示创建一个新数组，并可能初始化该新数组的元素。</span><br>System.Linq.Expressions.NewArrayExpression<br><span class="hljs-comment">//表示一个构造函数调用。</span><br>System.Linq.Expressions.NewExpression<br><span class="hljs-comment">//表示一个命名的参数表达式。</span><br>System.Linq.Expressions.ParameterExpression<br><span class="hljs-comment">//一个为变量提供运行时读/写权限的表达式。</span><br>System.Linq.Expressions.RuntimeVariablesExpression<br><span class="hljs-comment">//表示一个控制表达式，该表达式通过将控制传递到 SwitchCase 来处理多重选择。</span><br>System.Linq.Expressions.SwitchExpression<br><span class="hljs-comment">//表示一个 try/catch/finally/fault 块。</span><br>System.Linq.Expressions.TryExpression<br><span class="hljs-comment">//表示表达式和类型之间的操作。</span><br>System.Linq.Expressions.TypeBinaryExpression<br><span class="hljs-comment">//表示具有一元运算符的表达式。</span><br>System.Linq.Expressions.UnaryExpression<br><br></code></pre></td></tr></table></figure><p>由上面我们可以看出，Expression作为表达式树的一个基类，其派生了许多不同的子类，根据这些子类，我们可以实现不同的逻辑（此前真是没考虑过这方面，我以为只能去当作数据库查询语句呢，真特么惭愧），那么问题随之而来，我们应该怎么去应用这些子类，或者在什么时候可以运用他们呢？不急，今天我们首先简单了解一下Expression的相关概念及结构，先把基类研究明白了，其他子类日后可以慢慢研究。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>在此之前，我们先理解一下什么是表达式，表达式是由多个运算符和操作数组成，其中运算符表示要进行的操作，而操作数可以是一个变量、常量或者固定值。举例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">a&gt;b;<br>a=<span class="hljs-number">1</span>;<br>a=<span class="hljs-number">100</span>;<br><span class="hljs-keyword">var</span> a=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>;<br>a+b+c;<br></code></pre></td></tr></table></figure><p>以上这些都属于表达式，从上面的代码我可以看出，表达式的结构最简单可以分为左操作数，运算符，右操作数。三个基本的元素组成。</p><p>那么什么又是表达式树？官方给出的说法是：<strong>表达式树以树形数据结构表示代码，其中每一个节点都是一种表达式</strong>，这句话其实我刚开始理解起来呢，有些不太理解，但是在阅读了几篇关于表达式树的文章以后，大致有了一些理解。我的理解：<strong>表达式树就是一个可以拆分为多个子表达式的表达式所展开后的树形结构</strong>，具体如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">a=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>通过前面关于表达式介绍我们可以知道，这是一个包含加法表达式的赋值表达式，我们可以把它看作是一个表达式树，那么作为一个树形结构，我们首先把这个表达式本身看作最顶层的节点（树梢）。按照表达式的基本结构，我们首先看到左操作数（a），运算符（&#x3D;），右操作符（1+2），确定好顶层节点以后，我们开始往下去展开列出表达式的子节点，首先，该左操作数只有一个变量，那么该表达式树的第一个子节点就是左操作数变量’a’,然后第二个节点就是运算符 ‘&#x3D;’，而第三个节点则是右操作数（1+2），现在我们进一步将（1+2）看做成一个加法表达式，然后我们往下继续展开寻找子节点，那么该表达式的第一个子节点就是固定值1，第二个子节点则是运算符+，第三个子节点则是固定值2。至此，所有子节点均为个操作数或运算符，无法再继续往下展开，该表达式树结构就结束了。为了更直观的展示，我画了个结构图，其结构图如下：</p><p><img src="https://blog.renzhichu.top/1666099934017.jpg" alt="1666099934017"></p><br/><p>那么，这样一个结构，我们在代码中如何使用表达式树来进行标识呢？让我们来看下图：</p><p><img src="https://blog.renzhichu.top/1666104724435.jpg" alt="表达式"></p><p>由上图可以看出，我们先使用Constant方法定义出一个ConstantException类型的表达式作为左操作数，同理我们再声明出一个右操作数，之后，通过Expression提供的Add方法或者MakeBinary方法指定从需要操作的运算以及左右操作数，从而就会生成一个BinaryExpression类型的表达式，然后我们再通过Parameter方法生命出一个变量表达式，之后通过Assign（赋值表达式）将其组合起来，就又生成了一个全新的表达式，通过输出我们可以看到，其结构与我们上面的表达式结构一毛一样。所以这就是C#表达式树相关的整个结构与基本操作。</p>]]></content>
    
    
    <categories>
      
      <category>CSharp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AspNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次EF+Mysql所遇到的事务不生效的的坑</title>
    <link href="/2022/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%AE%B0%E4%B8%80%E6%AC%A1EF-Mysql%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E7%9A%84%E5%9D%91/"/>
    <url>/2022/08/31/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%AE%B0%E4%B8%80%E6%AC%A1EF-Mysql%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h2 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h2><p> 近期写的一个项目，整个项目采用的DDD（领域驱动）设计，所以刚开始设计的时候就将各个业务以聚合根的方式进行划分，以该业务场景为例，整体的业务简述为，当客户进行付款以后，创建一个付款单，然后由财务手动将付款单与发货单进行账务冲抵和关联，同时还需要针对付款的客户及企业的余额进行相应的变动，所以，当付款单和发货单进行冲抵业务的时候，客户及其企业的待付款金额将会根据冲抵的金额，进行变动，所以该业务的主要操作是首先针对发货单的待付款金额进行冲抵扣减，此时操作的聚合根为发货单的聚合根，而因为还需要同时针对用户的账户金额进行变动，所以在操作发货单的聚合根的时候，触发一个领域事件，而用户的聚合根订阅该事件，当该事件被触发的时候，用户的聚合根接收到事件，并随之进行相应的操作。</p><h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p> 一般情况下，领域事件可以看作一个一对多的多播事件即一方触发多方进行响应，一个聚合根发生改变并且触发领域事件的时候，其他与之关联的聚合根都将订阅该事件，在被触发的时候进行响应并对自身进行对应的操作，而且事件一般不会存在返回值的情况，所以订阅方的业务是否执行成功，失败后需要进行什么样的操作，可以根据业务的不同进行不同的操作，如果是需要强一致性的业务，就需要考虑操作异常的处理。如果是一致性不强的业务，则可以考虑自身重试等机制。而目前该项目所遇到的就是强一致性的业务需求，那么只能一荣俱荣，一损俱损。<br>在领域事件的是先方面，我采用的是NetCore项目中比较流行的MediatR组件（一种简单的实现进程内的消息传递机制的类库），采用MediatR的消息通知机制，在进行数据操作的时候，添加并触发领域事件，从而实现领域事件的触发以及订阅处理，同时采用EF的事务来确保数据库在操作数据时候的一致性。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//业务代码</span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 业务开始</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Task</span>(<span class="hljs-params">CancellationToken token=<span class="hljs-literal">default</span></span>)</span><br>&#123;<br>    <span class="hljs-comment">// 下面所用的未声明对象均有DI生成。</span><br>    <span class="hljs-comment">// DbCotext 继承 IUnitOfWork,并且通过IOC将其生命周期设为Scope（请求域） </span><br>    <span class="hljs-comment">//_repository 为聚合根的仓储类，在实例化时注入IUnitOfWork进行相应的数据库操作。</span><br>    <span class="hljs-comment">//具体略</span><br>    <span class="hljs-keyword">var</span> db = _repository.UnitOfWork <span class="hljs-keyword">as</span> TestDbContext;<br>    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> transaction=<span class="hljs-keyword">await</span> db.Database.BeginTransactionAsync(IsolationLevel.ReadCommitted,token))<br>    &#123;<br>        A a = <span class="hljs-keyword">new</span> A();<br>        a.AddDomainEvent(<span class="hljs-keyword">new</span> TestEvent());<br>        <span class="hljs-keyword">await</span> _repository.AddAsync(a);<br>        <span class="hljs-keyword">await</span> db.CommitTransactionAsync(transaction, token);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment">//数据库上下文部分方法</span><br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 异步提交事务</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;transaction&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">CommitTransactionAsync</span>(<span class="hljs-params">IDbContextTransaction transaction,CancellationToken cancellationToken=<span class="hljs-literal">default</span></span>)</span><br>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-keyword">await</span> EventTrigger(cancellationToken);<br>        <span class="hljs-keyword">await</span> SaveChangesAsync(cancellationToken);<br>        <span class="hljs-keyword">await</span> transaction.CommitAsync(cancellationToken);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception ex)<br>    &#123;<br>        <span class="hljs-keyword">await</span> RollbackTransactionAsync(cancellationToken);<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    <span class="hljs-keyword">finally</span><br>    &#123;<br>            transaction.Dispose();<br>            transaction = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 事件触发器</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">EventTrigger</span>(<span class="hljs-params">CancellationToken cancellationToken = <span class="hljs-literal">default</span>(CancellationToken</span>))</span><br>&#123;<br>    <span class="hljs-keyword">var</span> mediator =_serviceProvider.GetService&lt;IMediator&gt;()!;<br>    <span class="hljs-keyword">await</span> DispatchDomainEventAsync(mediator,cancellationToken);<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 调度领域事件</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;mediator&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;T&quot;&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DispatchDomainEventAsync</span>(<span class="hljs-params">IMediator mediator,CancellationToken cancellationToken = <span class="hljs-literal">default</span>(CancellationToken</span>))</span><br>&#123;<br>        <span class="hljs-comment">//当前上下文的所有添加了领域事件的聚合根</span><br>        List&lt;EntityEntry&lt;IAggregateRoot&gt;&gt; domainEntries = <span class="hljs-keyword">this</span>.ChangeTracker<br>        .Entries&lt;IAggregateRoot&gt;()<br>        .Where(x =&gt; x.Entity.DomainEvents.Any())<br>        .ToList();<br><br>    <span class="hljs-comment">//获取领域事件</span><br>    IEnumerable&lt;INotification&gt; domainEvents = domainEntries.SelectMany(x =&gt; x.Entity.DomainEvents).ToList();<br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> domainEntry <span class="hljs-keyword">in</span> domainEntries)<br>    &#123;<br>        domainEntry.Entity.ClearDomainEvent();<br>    &#125;<br><br>    <span class="hljs-comment">//发送事件</span><br>    <span class="hljs-keyword">var</span> tasks = domainEvents.Select(<span class="hljs-keyword">async</span> domainEvent =&gt;<br>    &#123;<br>        <span class="hljs-keyword">await</span> mediator.Publish(domainEvent, cancellationToken);<br>    &#125;);<br>    <span class="hljs-comment">//同时执行</span><br>    <span class="hljs-keyword">await</span> Task.WhenAll(tasks);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><br> <span class="hljs-comment">//订阅方</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestEventHandler</span>: <span class="hljs-title">INotificationHandler</span>&lt;<span class="hljs-title">TestEvent</span>&gt;<br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> fields</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IBRepository _repository;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> ctor</span><br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 事件处理方</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;repository&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestEventHandler</span>(<span class="hljs-params">IBRepository repository</span>)</span><br>    &#123;<br>        _repository = repository;<br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 处理程序</span><br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 处理程序</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;notification&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Handle</span>(<span class="hljs-params">TestEvent eventData, CancellationToken cancellationToken</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 参数 eventData 是可以传递数据的，此示例省略</span><br>        B b = <span class="hljs-keyword">new</span> B();<br>        b.Num = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">await</span> _repository.AddAsync(b);<br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>通过上面代码可以推断出，这次业务首先在操作之前开启ef事务，确保数据，一致性，然后在聚合根A进行保存之前触发领域事件，然后通过MediatR对事件进行调度，通知订阅方，而订阅方则根据自身的情况，实现自身的仓储，对操作进行处理。最后通过统一保存，提交事务，确保数据的一致性。</p><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><p>在业务代码实现以后，就针对该项业务进行测试，为了保险起见，专门针对数据一致性进行了测试，而结果大失所望，在数据进行保存的时候，故意调整了表结构的表A在保存的时候报错了没有将数据添加成功，而未调整的表B，则正常添加进了数据，数据的一致性并没有确保成功。这整个事情就变得很邪门了。而后就开始我的爬坑之旅。</p><h2 id="爬坑"><a href="#爬坑" class="headerlink" title="爬坑"></a>爬坑</h2><h3 id="1、怀疑DI生命周期是否规范"><a href="#1、怀疑DI生命周期是否规范" class="headerlink" title="1、怀疑DI生命周期是否规范"></a>1、怀疑DI生命周期是否规范</h3><p>起初，我以为是因为在进行调度的时候，采用了异步+Task的方式对领域事件进行了调度操作，所以导致事件在进行处理的时候和主方法的数据库上下不是一个导致的，所以针对数据库上下文的注入方式进行了排查，最后结果是 事件订阅处理方的数据库上下文和主方法的数据库上下文为同一个实例，所以不存在生命周期或不是实例不同的问题。</p><h3 id="2、怀疑项目架构问题"><a href="#2、怀疑项目架构问题" class="headerlink" title="2、怀疑项目架构问题"></a>2、怀疑项目架构问题</h3><p>因为整个项目的架构都是我自己搭建的，出于对自身能力的怀疑，于是就有上面Demo的诞生，上面的Demo是我根据思路又重新调整后写的,结果神奇的一幕出现了，上面的框架事务生效了！！！！（但是这又是另外一个坑，不过不知道是不是负负得正把，反正促使我找到了真正的问题。）</p><h3 id="3、加载调试日志"><a href="#3、加载调试日志" class="headerlink" title="3、加载调试日志"></a>3、加载调试日志</h3><p>在这个阶段，我进行了疯狂的调试，在调试的时候，特意输出了EF的Debug日志。从事务开启，到事务保存前创建事务保存点，再到保存，报错，回滚，删除事务保存点，这些日志我全都看到EF输出出来了并且排查了一遍，各种操作层出不穷，不再赘述，反正没有解决。</p><h3 id="4、怀疑EF"><a href="#4、怀疑EF" class="headerlink" title="4、怀疑EF"></a>4、怀疑EF</h3><p>不得不说我飘了，我真真切切的开始怀疑过EFCore，甚至把这部分源码以及文档看了一遍，结果还是没看出什么所以然来。还是无果。</p><h2 id="逃出生天"><a href="#逃出生天" class="headerlink" title="逃出生天"></a>逃出生天</h2><p>最后！！！！我要感恩的是马桶，在我一次次一天天的失败后，与 <del>昨晚</del>（今天凌晨）12：30在我心灰意冷关了电脑以后，坐在马桶上思考解决方案，随手用手机搜了一下Mysql事务打开了一篇博客，具体博客内容我忘了，是一篇JAVA的，但是核心内容是在JAVA中开启事务不管用的情况，一下我就来劲了，仔细一看，卧槽，我怀疑这个，怀疑那个，为毛就是没有怀疑过是Mysql的问题呢？Mysql的存储引擎，我所使用的版本是5.7.26，它默认的存储引擎是MyISAM的，这玩意它不支持事务啊！！！！！它不支持！！！</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在我恶补了Mysql数据库引擎区别以后，我将数据库的存储引擎改为InnoDB后，完美！！！解决了！！（具体区别可以去搜一下，网上到处都是，烂大街了都，我就不复制别人的了）两周，整整两周，只要有时间，就在电脑前摸索研究这个问题，最后却发现是这么一个不起眼的问题导致的。却也说明了我个人对数据库知识的薄弱，后期需要恶补数据库。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>EF</tag>
      
      <tag>Net6</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次netcore在linux服务器上出现的诡异的failed to create coreclr hresult:0x80004005的问题</title>
    <link href="/2022/05/29/uncategorized/NetCore%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%AF%A1%E5%BC%82%E7%9A%84Failed%20to%20create%20CoreCLR%20%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/29/uncategorized/NetCore%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%AF%A1%E5%BC%82%E7%9A%84Failed%20to%20create%20CoreCLR%20%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#问题<br><img src="http://blog.renzhichu.top/1653830678.png" alt="问题图片"></p><p>#场景<br> 使用脚本，拉取Git代码，将NetCore程序发布到docker中去。在发布的时候会提示：failed to create coreclr hresult:0x80004005 然后 执行其他netcore命令也会提示：failed to create coreclr hresult:0x80004005</p><p>#解决方案<br> 首先看看脚本拉取代码，并且进行编译发布的时候，是否存在权限问题，对文件夹是否具有读写权限，<br> 其次再看看当前的硬盘空间是否还有空间，是不是磁盘空间满了。<br> 然后再看看针对&#x2F;tmp文件夹是否具有读写权限，或者&#x2F;tmp文件夹是否存在。</p><p>#解决过程<br>  <img src="http://blog.renzhichu.top/1653831900(1).jpg" alt="解决过程"><br>  <img src="http://blog.renzhichu.top/1653831948.jpg" alt="解决过程"></p><p>#最后<br> 完美解决，拜拜！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>牛牛的Redis的学习笔记--第一章</title>
    <link href="/2022/03/22/Redis/%E7%89%9B%E7%89%9B%E7%9A%84Redis%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2022/03/22/Redis/%E7%89%9B%E7%89%9B%E7%9A%84Redis%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<H1> 牛牛的Redis的学习笔记--第一章</H1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>最近闲来无事，入手了一本钱文品老师的《Redis深度历险-核心原理与应用实践》一书，于是便偶尔翻几页学习一下Redis,毕竟用了好几年了，但是一些底层的核心内容一直没有系统的了解过，借此机会也让自己对Redis有个更深得了解吧。现在把第一张的内容进行总结并且记录一下，自己也在下面使用笔记本记录了一些要点，但是笔记本总是放着放着不知道拿哪里去了，搞了在不同的笔记本上东记一些西记一些，这里写个学习笔记，算是归纳整理吧，放在网上，也能跟朋友们交流下。</p></blockquote><H2>1、Redis的基础结构：</H2>Redis常用的数据结构分为： <li>string(字符串)</li> <li>list（列表）</li> <li>hash（字典）</li> <li>set（集合）</li> <li>zset（有序集合）</li>Redis特殊的数据结构： <li>HyperLogLog</li> <li>BitMap（位图）</li> <li>布隆过滤器</li><br> <H3> 1、string的相关知识：</H3> <H4> 1.1、string的基本概念及实现</H4><blockquote><p>Redis的字符串时动态字符串，是可以修改的，Redis每次申请字符串空间的时候，是采用预分配冗余空间的方式进行分配的。<br> 其内部字符串分配的空间内存，一定是高于储存的字符串的。如果说字符串小于1M那么每次申请到的内存是储存内存的一倍，<br> 如果字符串大于1M时，那么每次申请都是以1M 进行扩容的。注意：字符串的最大空间（字符串的长度）是512M。<br> 而字符串的底部实现则是以位图实现的，字符串是由多个字符组成的，而一个字符则是由八个位（bit）组成的，<br> 所以一串字符串则是由好多个8位数组组成</p></blockquote><h4 id="1-2、string的相关命令"><a href="#1-2、string的相关命令" class="headerlink" title="1.2、string的相关命令"></a>1.2、string的相关命令</h4><p> string相当于键值对，支持简单的增删改查。命令一般有：</p><p> <strong>单个操作：</strong></p><ul><li><p>set key</p></li><li><p>get key</p></li></ul><p> <strong>批量操作：</strong></p> <li>mset key value key value key value</li> <li>mget key key key key</li><br> <br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gams">&gt; <span class="hljs-keyword">set</span> test 牛牛<br>OK<br>&gt; get <span class="hljs-comment">test</span><br><span class="hljs-string">&quot;牛牛&quot;</span><br>&gt; mset <span class="hljs-comment">test0</span> 牛牛 <span class="hljs-comment">test1</span> 壮壮 <span class="hljs-comment">test2</span> 瞳瞳<br>OK<br>&gt; mget <span class="hljs-comment">test test0 test1 test2</span><br>1) <span class="hljs-string">&quot;牛牛&quot;</span><br>2) <span class="hljs-string">&quot;牛牛&quot;</span><br>3) <span class="hljs-string">&quot;壮壮&quot;</span><br>4) <span class="hljs-string">&quot;瞳瞳&quot;</span><br>&gt; mget <span class="hljs-comment">test0 test1 test2</span><br>1) <span class="hljs-string">&quot;牛牛&quot;</span><br>2) <span class="hljs-string">&quot;壮壮&quot;</span><br>3) <span class="hljs-string">&quot;瞳瞳&quot;</span><br><br></code></pre></td></tr></table></figure><p>设置过期时间：</p><li>expire key time</li><li> setex key time value</li> <br><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">expire test <span class="hljs-number">1</span></span><br>(integer) 1<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">get test</span><br>(nil)<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">get test1</span><br>&quot;壮壮&quot;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">expire test1 <span class="hljs-number">1</span></span><br>(integer) 1<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">get test1</span><br>(nil)<br><br></code></pre></td></tr></table></figure><p><strong>不存在就添加,但是存在就不改变（返回0&#x2F;1来区分是否添加成功）</strong></p><li>setnx key value</li><br><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setnx test2 <span class="hljs-number">111</span></span><br>(integer) 0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setnx test3 <span class="hljs-number">111</span></span><br>(integer) 1<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">get test2</span><br>&quot;瞳瞳&quot;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">get test4</span><br>(nil)<br></code></pre></td></tr></table></figure><H3>2、List(列表)的相关知识</H3><blockquote><p>Redis的列表相当于java中的LinkedList<br>(链表还是双向链表 &#x2F;&#x2F;TODO:根据之前的Demo写一篇链表的博客—20220300),<br>这意味着Redis中List的插入和删除操作是非常快的，<br>其时间复杂度位O(1),但是索引的速度确实很慢，时间负责都为O(n)。<br>Redis的列表有多种用途，<br>当他从右边进并从左边出的时候，可以看做是队列。<br>然当他左边进左边出（或者右进右出）的时候可以就可以看成是栈,<br>而list也可以当作延时队列进行来使用。在一侧添加消息，并在另一侧对消息进行轮询弹出进行处理。</p></blockquote> <H4>2.1、list的相关命令</H4><p><strong>推进和弹出</strong></p> <li>rpush key values</li> <li>rpop key</li> <li>lpush key values</li> <li>lpop key</li> <figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><br> &gt; rpush listtest C#<br>(integer) 1<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">rpush listtest java</span><br>(integer) 2<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">rpush listtest php</span><br>(integer) 3<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">rpush listtest js</span><br>(integer) 4<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">rpop listtest</span><br>&quot;js&quot;<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">lpop listtest</span><br>&quot;C#&quot;<br><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">rpush tt C# java php</span><br>(integer) 3<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">rpush tt android node go python</span><br>(integer) 7<br><br>//push 可添加多个元素<br><br></code></pre></td></tr></table></figure><p><strong>遍历定位</strong><br> <li>lindex key index</li><br>lindex用于对列表进行遍历定位，性能消耗随着index的数值增大而增加。</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tcl"><span class="hljs-keyword">lindex</span> listtest <span class="hljs-number">0</span><br><span class="hljs-string">&quot;java&quot;</span><br>&gt; <span class="hljs-keyword">lindex</span> listtest <span class="hljs-number">5</span><br>(nil)<br>&gt; <span class="hljs-keyword">lindex</span> listtest <span class="hljs-number">-1</span><br><span class="hljs-string">&quot;php&quot;</span><br>&gt; <span class="hljs-keyword">lindex</span> listtest <span class="hljs-number">1</span><br><span class="hljs-string">&quot;php&quot;</span><br><br>//之前的命令已将 C# 和js 弹出，所以此时列表里只存在两个元素，<br>在坐标中，<span class="hljs-number">-1</span>代表着最后一个元素。也就是最右边的元素（列表是从左到右排列）<br><br></code></pre></td></tr></table></figure><p><strong>截取保留（修剪）:该命令会保留区间内的所有元素，并且删除区间外的所有元素</strong></p><p><strong>返回列表元素：返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。 你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素 如果start是0 而end是-1 则返回正向所有元素</strong></p><p>&#x2F;&#x2F;返回列表元素</p><li>lrange key start_index end_index</li> <p>&#x2F;&#x2F;截取保留</p><li>ltrim &nbsp; key &nbsp; start_index ;&nbsp; end_index</li><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tcl">&gt; <span class="hljs-keyword">lrange</span> tt <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;C#&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;java&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;php&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;android&quot;</span><br><span class="hljs-number">5</span>) <span class="hljs-string">&quot;node&quot;</span><br><span class="hljs-number">6</span>) <span class="hljs-string">&quot;go&quot;</span><br><span class="hljs-number">7</span>) <span class="hljs-string">&quot;python&quot;</span><br><br>&gt; ltrim tt <span class="hljs-number">2</span> <span class="hljs-number">5</span><br>OK<br><br>&gt; <span class="hljs-keyword">lrange</span> tt <span class="hljs-number">0</span> <span class="hljs-number">-1</span><br><span class="hljs-number">1</span>) <span class="hljs-string">&quot;php&quot;</span><br><span class="hljs-number">2</span>) <span class="hljs-string">&quot;android&quot;</span><br><span class="hljs-number">3</span>) <span class="hljs-string">&quot;node&quot;</span><br><span class="hljs-number">4</span>) <span class="hljs-string">&quot;go&quot;</span><br><br>//可以发现从第三个元素到第六个元素还存在于列表中，其他的已经被裁剪掉了<br><br></code></pre></td></tr></table></figure><h4 id="2-2、注意："><a href="#2-2、注意：" class="headerlink" title="2.2、注意："></a>2.2、注意：</h4><blockquote><p>Redis的列表并不是普通的链表，而是快速链表（quicklist），首先在元素较少的情况下，列表是使用一块连续的内存进行储存的，这个结构是ziplist(压缩列表)。它将所有的元素都彼此紧挨着一起储存。当数据量比较多的时候，则会改成quicklist进行储存，因为普通的链表需要的附加指针空间太大，会浪费时间，还会加重内存的碎片化，。所以Redis将链表和ziplist结合组成了quicklist,就是将多个ziplist使用双向指针进行串联，既能满足快速的插入删除，又不会出现太大的冗余。</p></blockquote><h3 id="3、hash-哈希表–字典-的相关知识"><a href="#3、hash-哈希表–字典-的相关知识" class="headerlink" title="3、hash(哈希表–字典)的相关知识"></a>3、hash(哈希表–字典)的相关知识</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Redis的<span class="hljs-built_in">hash</span>和C<span class="hljs-comment">#的Dictionary&lt;,&gt;的结构是一毛一样的。</span><br></code></pre></td></tr></table></figure><h4 id="3-1、hash的命令："><a href="#3-1、hash的命令：" class="headerlink" title="3.1、hash的命令："></a>3.1、hash的命令：</h4><p>设置和获取</p><li>hset key hkey value</li><li>hget key heky</li><br><p>获取key下的全部数据</p><li>hgetall key</li><br><p>获取key下的二级键值对数量</p><li>hlen</li><br><p>设置二级键值对数值计数</p><li>hincrby</li><h3 id="4、set（集合）的相关知识"><a href="#4、set（集合）的相关知识" class="headerlink" title="4、set（集合）的相关知识"></a>4、set（集合）的相关知识</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Redis</span>的集合其实就是相当于<span class="hljs-built_in">C</span><span class="hljs-type">#</span>中的<span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">T</span><span class="hljs-operator">&gt;</span>具体泛型是什么类型的，需要看具体插入的值（这里泛型仅作比如，具体的类型没啥用）。当集合的最后一个元素被移除后，结构就会被自动删除。内存则会被回收，该结构具有去重的功能，所以一边可用于储存中奖结果名单之类的作用，可以确保用户不会被抽中两次。<br></code></pre></td></tr></table></figure><h4 id="4-1、set（集合）的命令"><a href="#4-1、set（集合）的命令" class="headerlink" title="4.1、set（集合）的命令"></a>4.1、set（集合）的命令</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml">添加和获取元素<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>sadd key values <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>smembers key<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>判断一个元素是否存在<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>sismember key value<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>查询集合中的元素数量<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>scard key<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>随机弹出一个值<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>spop key<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5、zset（有序集合）的相关知识"><a href="#5、zset（有序集合）的相关知识" class="headerlink" title="5、zset（有序集合）的相关知识"></a>5、zset（有序集合）的相关知识</h3><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml">Redis的有序集合其实和集合的区别就是它比集合多了个<span class="hljs-variable language_">score</span>（权重概念），而集合中的元素，可以根据<span class="hljs-variable language_">score</span>的变化，进行排序，<br>其内部实现用的是一种叫做“跳跃列表”的数据结构。同样的有序集合中最后一个元素被移除的时候数据结构就会被删除，内存就会被回收，有序集合通常用于储存 粉丝列表，用value来保存用户Id,用<span class="hljs-variable language_">score</span>来记录关注时间（时间戳），也可储存学生的成绩，value储存学生的<span class="hljs-variable language_">id</span>,<span class="hljs-variable language_">score</span>储存成绩，个人猜测：微信的步数列表、附近的人，应该是用这个进行储存的。<br></code></pre></td></tr></table></figure><h4 id="5-1、zset（有序集合）的命令"><a href="#5-1、zset（有序集合）的命令" class="headerlink" title="5.1、zset（有序集合）的命令"></a>5.1、zset（有序集合）的命令</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml">添加和获取元素<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zadd key score values <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>按照权重正向排出区间内的元素<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zrange key start_index end_index<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>按照权重逆向排出区间内的元素<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zrevrange key start_index end_index<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>查询集合中的元素数量<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zcard key<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>获取指定value的权重<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zscore key value<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>获取指定value的排名<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zrank key value<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>获取权重区间内的元素<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zrangebyscore key start_score end_score<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>删除一个值<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>zrem key<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Redis的数据结构类型及其通用规则"><a href="#Redis的数据结构类型及其通用规则" class="headerlink" title="Redis的数据结构类型及其通用规则"></a>Redis的数据结构类型及其通用规则</h2><h3 id="1、容器类型数据结构"><a href="#1、容器类型数据结构" class="headerlink" title="1、容器类型数据结构"></a>1、容器类型数据结构</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">在Redis中 <span class="hljs-keyword">list</span>、<span class="hljs-keyword">set</span>、hash、zset 这四种数据结构属于容器行数据结构，他们均有一下两条通用规则&lt;<span class="hljs-keyword">br</span>&gt;<br>&lt;<span class="hljs-keyword">li</span>&gt;一、如果容器不存在就创建一个，再进行操作。&lt;/<span class="hljs-keyword">li</span>&gt;<br>&lt;<span class="hljs-keyword">li</span>&gt;二、如果最后一个元素被取出或者删除了，那么容器就会消失，内存回收释放。<br></code></pre></td></tr></table></figure><h2 id="Redis的过期时间"><a href="#Redis的过期时间" class="headerlink" title="Redis的过期时间"></a>Redis的过期时间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Redis的所有数据结构都可以设置过期时间，时间到了，Redis会自动删除相应的对象，但是过期时间是以对象为单位的，所以<span class="hljs-built_in">hash</span>并不能对某个二级key设置过期时间，还有就是如果一个字符串设置了过期时间，那么如果再次调用<span class="hljs-built_in">set</span>命令的话过期时间会消失。<br><br></code></pre></td></tr></table></figure><h2 id="位图的应用场景及使用方式"><a href="#位图的应用场景及使用方式" class="headerlink" title="位图的应用场景及使用方式"></a>位图的应用场景及使用方式</h2><blockquote><p>刚听说位图的时候，觉得这是一块很难懂的玩意，又是bit又是字符串的，但是当潜下心来了解的时候发现其实一点都不难，Redids的字符串，每个英文字母是一个字节，而一个字节是八个bit,而一个字符串就是一堆以八个bit为一组的数组，每个bit不是1就是0，也可以看作非真即假，这个时候，我们可以把这个玩意儿用于储存比如内日签到记录，或者每日登记之类的场景，因为是否签到，就是非真即假，签到了我们就存个1，没签到我们就存个0。这样一年的签到记录也就是个45个字的字符串。。。。<br>位图的命令也很简单</p></blockquote><ul><li>setbit key offset value</li><li>getbit key offset</li></ul><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">set h h</span><br>OK<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">0</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">1</span></span><br>1<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">2</span></span><br>1<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">3</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">4</span></span><br>1<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">5</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">6</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">getbit h <span class="hljs-number">7</span></span><br>0<br><br>// 01101000<br><br>/*<br>使用py解析下h的二进制编码<br>&gt;&gt;&gt; bin(ord(&#x27;h&#x27;))<br>&#x27;01101000&#x27;<br>&gt;&gt;&gt;<br>*/<br><br>可以发现一毛一样，不过！！<br>正常的二进制是从高位到地位的， 也就是说py解析出来的八个数字。其实是<br>76543210以这样排列，但是Redis中位图则是从低到高进行排列的。<br>所以跟正常的二进制刚好是相反的01234567<br>接下来我们可以通过位图添加出一个字符<br><br>setbit t 0 0<br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setbit t <span class="hljs-number">1</span> <span class="hljs-number">1</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setbit t <span class="hljs-number">2</span> <span class="hljs-number">1</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setbit t <span class="hljs-number">3</span> <span class="hljs-number">0</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setbit t <span class="hljs-number">4</span> <span class="hljs-number">1</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setbit t <span class="hljs-number">5</span> <span class="hljs-number">0</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setbit t <span class="hljs-number">6</span> <span class="hljs-number">0</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">setbit t <span class="hljs-number">7</span> <span class="hljs-number">0</span></span><br>0<br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">get t</span><br>&quot;h&quot;<br><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">bitcount h</span><br>3<br>//上面这个命令则是统计这个Key的位图里有几个1，意味着位图如果使用到签到场景的话，可以统计整个记录里面签到多少次。如果指定了参数范围，则可以查看这个范围内的签到次数，但是注意，指定的范围，只能是8的倍数，而不能任意指定。<br><br></code></pre></td></tr></table></figure><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><p> 常用的数据存储中，我们针对一个完整的结构，是直接存储json还是分开存储属性？比如用户信息。我们是把整个用户信息进行存储还是以用户id为命名空间，下面存储各个信息的单独属性。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MediatR源码详解</title>
    <link href="/2021/08/23/%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/MediatR%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/08/23/%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/MediatR%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MediatR源码详解-就差手摸手了"><a href="#MediatR源码详解-就差手摸手了" class="headerlink" title="MediatR源码详解(就差手摸手了)"></a>MediatR源码详解(就差手摸手了)</h1><h2 id="一、项目介绍"><a href="#一、项目介绍" class="headerlink" title="一、项目介绍"></a>一、项目介绍</h2><p>  &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;MediatR是.NET中一种简单的实现进程内的消息传递机制的类库。支持同步或者异步的形式进行请求响应，命令，查询。通知和事件的传递<br><br>  &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;github地址：<a href="https://github.com/jbogard/MediatR">https://github.com/jbogard/MediatR</a><br><br>  &amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;作者：jbogard <br></p><h2 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h2><h3 id="2-1、消息传递之单点传递："><a href="#2-1、消息传递之单点传递：" class="headerlink" title="2.1、消息传递之单点传递："></a>2.1、消息传递之单点传递：</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;所谓的单点传递，就是在消息传递中，存在一个发消息的，还存在一个接收消息的，就像生活中，我们聊QQ&#x2F;微信就属于消息传递，而我们现在要聊的就是消息传递中的单点传递也就是私聊，一对一的进行传递。</p><h4 id="2-1-1-IRequest-接口："><a href="#2-1-1-IRequest-接口：" class="headerlink" title="2.1.1 IRequest 接口："></a>2.1.1 IRequest 接口：</h4>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Marker interface to represent a request with a void response</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRequest</span> : <span class="hljs-title">IRequest</span>&lt;<span class="hljs-title">Unit</span>&gt; &#123; &#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Marker interface to represent a request with a response</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span>Response type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRequest</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">TResponse</span>&gt; : <span class="hljs-title">IBaseRequest</span> &#123; &#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Allows for generic type constraints of objects implementing IRequest or IRequest&#123;TResponse&#125;</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IBaseRequest</span> &#123; &#125;<br><br></code></pre></td></tr></table></figure><p>  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IRequest相关接口,在消息传递中，是用于一对一的消息传递参数请求所定义相关参数规范的接口，可以理解为定义消息传递的参数格式所需要的接口 我们可以看到，这里有三个相关接口，最底层的是IBaseRequest接口，然后是一个IRequest&lt;TRequest&gt;接口，最后是IRequest接口,首先讲一下三个接口，IBaseRequest接口，其实就是最基础的接口，起到了一个类型约束的作用，所有的参数类型，都必须继承自IBaseRequst接口，而IRequestt&lt;TRequest&gt;接口呢，则是定义了在消息传递的逻辑处理中，所需要返回的返回值的类型，这样就起到了，消息的传递以及响应的作用，发出消息也定义了这个消息所需要的响应是什么。最后一个IRequest接口，继承于IRequest&lt;Unit&gt;接口，这是什么意思呢，这就很厉害了，它是用Unit结构，来当作返回类型，从而实现了无返回值的消息参数类型。</p><h3 id="2-1-2-IRequestHandler接口："><a href="#2-1-2-IRequestHandler接口：" class="headerlink" title="2.1.2 IRequestHandler接口："></a>2.1.2 IRequestHandler接口：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Defines a handler for a request</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span>The type of request being handled<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span>The type of response from the handler<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRequestHandler</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">IRequest</span>&lt;<span class="hljs-title">TResponse</span>&gt;<br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Handles a request</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;request&quot;&gt;</span>The request<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>Cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Response from the request<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function">Task&lt;TResponse&gt; <span class="hljs-title">Handle</span>(<span class="hljs-params">TRequest request, CancellationToken cancellationToken</span>)</span>;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Defines a handler for a request with a void (<span class="hljs-doctag">&lt;see cref=&quot;Unit&quot; /&gt;</span>) response.</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> You do not need to register this interface explicitly with a container as it inherits from the base <span class="hljs-doctag">&lt;see cref=&quot;IRequestHandler&#123;TRequest, TResponse&#125;&quot; /&gt;</span> interface.</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span>The type of request being handled<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IRequestHandler</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">TRequest</span>&gt; : <span class="hljs-title">IRequestHandler</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">Unit</span>&gt;  <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">IRequest</span>&lt;<span class="hljs-title">Unit</span>&gt;<br>&#123;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Wrapper class for a handler that asynchronously handles a request and does not return a response</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span>The type of request being handled<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncRequestHandler</span>&lt;<span class="hljs-title">TRequest</span>&gt; : <span class="hljs-title">IRequestHandler</span>&lt;<span class="hljs-title">TRequest</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">IRequest</span><br>&#123;<br>    <span class="hljs-keyword">async</span> Task&lt;Unit&gt; IRequestHandler&lt;TRequest, Unit&gt;.Handle(TRequest request, CancellationToken cancellationToken)<br>    &#123;<br>        <span class="hljs-keyword">await</span> Handle(request, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> Unit.Value;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Override in a derived class for the handler logic</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;request&quot;&gt;</span>Request<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Response<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Task <span class="hljs-title">Handle</span>(<span class="hljs-params">TRequest request, CancellationToken cancellationToken</span>)</span>;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Wrapper class for a handler that synchronously handles a request and returns a response</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span>The type of request being handled<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span>The type of response from the handler<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestHandler</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt; : <span class="hljs-title">IRequestHandler</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">IRequest</span>&lt;<span class="hljs-title">TResponse</span>&gt;<br>&#123;<br>    Task&lt;TResponse&gt; IRequestHandler&lt;TRequest, TResponse&gt;.Handle(TRequest request, CancellationToken cancellationToken)<br>        =&gt; Task.FromResult(Handle(request));<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Override in a derived class for the handler logic</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;request&quot;&gt;</span>Request<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Response<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> TResponse <span class="hljs-title">Handle</span>(<span class="hljs-params">TRequest request</span>)</span>;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Wrapper class for a handler that synchronously handles a request does not return a response</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span>The type of request being handled<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestHandler</span>&lt;<span class="hljs-title">TRequest</span>&gt; : <span class="hljs-title">IRequestHandler</span>&lt;<span class="hljs-title">TRequest</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">IRequest</span><br>&#123;<br>    Task&lt;Unit&gt; IRequestHandler&lt;TRequest, Unit&gt;.Handle(TRequest request, CancellationToken cancellationToken)<br>    &#123;<br>        Handle(request);<br>        <span class="hljs-keyword">return</span> Unit.Task;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">TRequest request</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;既然说到了微信聊天，我们肯定知道聊天最起码得是俩人的事，特别是私聊，对面必须的有一个消息接收者，没有接收者我们发出去的就不是消息，而是寂寞。而IRequestHandler接口的主要作用是接收消息参数进行响应的逻辑处理,在这个接口下面，还有三个抽象类，采用的是包装器模式，对这个接口进行额外的功能实现，<br>可以看出，这三个抽象类实现了有响应，无响应这两种情况的同步以及异步不同模式下的处理方式（就像Boss直聘里面经常出现的：消息未读、已读不回、还有已读明天回），而方法中的抽象方法更是为了在不同情况下，所继承的实现类根据具体业务来实现具体逻辑使用。</p><h3 id="2-2、消息传递之消息通知"><a href="#2-2、消息传递之消息通知" class="headerlink" title="2.2、消息传递之消息通知"></a>2.2、消息传递之消息通知</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通知,这个就有趣了，通知可以是单独通知一个人，也可以通知一群人，在经历2020年初疫情之后，大家肯定对网上很火某地村长拿大喇叭喊话通知这段视频记忆犹新吧，从这里我们就可以看出消息的通知，可以是针对一到N个人进行通知的，而且通知后不需要每个人进行回复响应，想要接收到通知以后有条不紊的做就完了。所以接下来说的就是项目中通知的实现。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Marker interface to represent a notification</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">INotification</span> &#123; &#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Defines a handler for a notification</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TNotification&quot;&gt;</span>The type of notification being handled<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">INotificationHandler</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">TNotification</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TNotification</span> : <span class="hljs-title">INotification</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Handles a notification</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;notification&quot;&gt;</span>The notification<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>Cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function">Task <span class="hljs-title">Handle</span>(<span class="hljs-params">TNotification notification, CancellationToken cancellationToken</span>)</span>;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Wrapper class for a synchronous notification handler</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TNotification&quot;&gt;</span>The notification type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NotificationHandler</span>&lt;<span class="hljs-title">TNotification</span>&gt; : <span class="hljs-title">INotificationHandler</span>&lt;<span class="hljs-title">TNotification</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TNotification</span> : <span class="hljs-title">INotification</span><br>&#123;<br>    Task INotificationHandler&lt;TNotification&gt;.Handle(TNotification notification, CancellationToken cancellationToken)<br>    &#123;<br>        Handle(notification);<br>        <span class="hljs-keyword">return</span> Unit.Task;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Override in a derived class for the handler logic</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;notification&quot;&gt;</span>Notification<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Handle</span>(<span class="hljs-params">TNotification notification</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通知，既然是一对多的，那么什么人可以收到通知呢？我们从上面代码可以看到通知只有一个简单的INotification接口，他的作用也仅仅是起到个类型约束的作用，所有发送的通知类都必须继承此接口，但是如何去接收指定类型通知呢？或者换句话说，我怎么知道这个通知是不是通知给我的呢？我们先把这个问题放在这里，后面会讲到。</p><h3 id="2-3、消息处理管道"><a href="#2-3、消息处理管道" class="headerlink" title="2.3、消息处理管道"></a>2.3、消息处理管道</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;消息处理管道，管道我们都知道，就不再赘述了，就是你脑子里想到的那个东西，不管你想到的是啥，反正作用差不多，那么消息处理管道是干什么的，我们先看源码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Represents an async continuation for the next task to execute in the pipeline</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span>Response type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Awaitable task returning a <span class="hljs-doctag">&lt;typeparamref name=&quot;TResponse&quot;/&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-title">Task</span>&lt;<span class="hljs-title">TResponse</span>&gt; <span class="hljs-title">RequestHandlerDelegate</span>&lt;<span class="hljs-title">TResponse</span>&gt;()</span>;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Pipeline behavior to surround the inner handler.</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Implementations add additional behavior and await the next delegate.</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span>Request type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span>Response type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IPipelineBehavior</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">notnull</span><br>&#123;<br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Pipeline handler. Perform any additional behavior and await the <span class="hljs-doctag">&lt;paramref name=&quot;next&quot;/&gt;</span> delegate as necessary</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;request&quot;&gt;</span>Incoming request<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>Cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;next&quot;&gt;</span>Awaitable delegate for the next action in the pipeline. Eventually this delegate represents the handler.<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>Awaitable task returning the <span class="hljs-doctag">&lt;typeparamref name=&quot;TResponse&quot;/&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function">Task&lt;TResponse&gt; <span class="hljs-title">Handle</span>(<span class="hljs-params">TRequest request, CancellationToken cancellationToken, RequestHandlerDelegate&lt;TResponse&gt; next</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;所谓请求处理管道，即在传递传递过程对消息进行额外处理的，举个不恰当的例子，大家都见过流水线，一批批产品放在流水线上，然后过一个地方就会被进行相应的处理，比如可口可乐吧，先是装瓶、然后盖盖、然后包装、喷日期、这系列下来最后才成为一个可以出场的产品，大家可以把请求处理管道理解从请求到接收请求处理的过程看作一个流水线，然后管道处理程序就像是装瓶喷日期等操作，虽然不恰当，但是我个人觉得，很形象，在管道中我们可以先校验信息的安全性，以及参数的是否符合规范，熟悉.NetCore的应该可以立马想起来.NET Core中的请求管道和中间件的构建，先构建管道，然后再消息传递过程中去执行管道。<br></p><p>在IPipelineBehavior接口下还实现了有两个类：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Behavior for executing all <span class="hljs-doctag">&lt;see cref=&quot;IRequestPreProcessor&#123;TRequest&#125;&quot;/&gt;</span> instances before handling a request</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span><span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestPreProcessorBehavior</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt; : <span class="hljs-title">IPipelineBehavior</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">notnull</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IEnumerable&lt;IRequestPreProcessor&lt;TRequest&gt;&gt; _preProcessors;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestPreProcessorBehavior</span>(<span class="hljs-params">IEnumerable&lt;IRequestPreProcessor&lt;TRequest&gt;&gt; preProcessors</span>)</span><br>    &#123;<br>        _preProcessors = preProcessors;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;TResponse&gt; <span class="hljs-title">Handle</span>(<span class="hljs-params">TRequest request, CancellationToken cancellationToken, RequestHandlerDelegate&lt;TResponse&gt; next</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> processor <span class="hljs-keyword">in</span> _preProcessors)<br>        &#123;<br>            <span class="hljs-keyword">await</span> processor.Process(request, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> next().ConfigureAwait(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Behavior for executing all <span class="hljs-doctag">&lt;see cref=&quot;IRequestPostProcessor&#123;TRequest,TResponse&#125;&quot;/&gt;</span> instances after handling the request</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TRequest&quot;&gt;</span>Request type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span>Response type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestPostProcessorBehavior</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt; : <span class="hljs-title">IPipelineBehavior</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt;<br>    <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">notnull</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IEnumerable&lt;IRequestPostProcessor&lt;TRequest, TResponse&gt;&gt; _postProcessors;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestPostProcessorBehavior</span>(<span class="hljs-params">IEnumerable&lt;IRequestPostProcessor&lt;TRequest, TResponse&gt;&gt; postProcessors</span>)</span><br>    &#123;<br>        _postProcessors = postProcessors;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;TResponse&gt; <span class="hljs-title">Handle</span>(<span class="hljs-params">TRequest request, CancellationToken cancellationToken, RequestHandlerDelegate&lt;TResponse&gt; next</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> response = <span class="hljs-keyword">await</span> next().ConfigureAwait(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> processor <span class="hljs-keyword">in</span> _postProcessors)<br>        &#123;<br>            <span class="hljs-keyword">await</span> processor.Process(request, response, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这两个类主要是供大家在项目中使用的时候去继承的，一个是用于请求前处理消息，一个是用于请求后处理消息。不过大家也可以直接去继承IPipelineBehavior接口去实现我们自己的逻辑。<br></p><p>话到这里有个问题，我们如何保证其调用的先后顺序呢？我们还是先放放，继续向下<br></p><h3 id="2-3、核心功能实现："><a href="#2-3、核心功能实现：" class="headerlink" title="2.3、核心功能实现："></a>2.3、核心功能实现：</h3><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 在此之前我们把必要的接口都过了一遍了，而他们那么多全都是为了实现一个功能，消息的发送与通知。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IMediator</span><br>    &#123;<br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> Asynchronously send a request to a single handler</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;typeparam name=&quot;TResponse&quot;&gt;</span>Response type<span class="hljs-doctag">&lt;/typeparam&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;request&quot;&gt;</span>Request object<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>Optional cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A task that represents the send operation. The task result contains the handler response<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-title">Task</span>&lt;<span class="hljs-title">TResponse</span>&gt; <span class="hljs-title">Send</span>&lt;<span class="hljs-title">TResponse</span>&gt;(<span class="hljs-params">IRequest&lt;TResponse&gt; request, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)</span>;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> Asynchronously send an object request to a single handler via dynamic dispatch</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;request&quot;&gt;</span>Request object<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>Optional cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A task that represents the send operation. The task result contains the type erased handler response<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>        Task&lt;<span class="hljs-built_in">object</span>?&gt; Send(<span class="hljs-built_in">object</span> request, CancellationToken cancellationToken = <span class="hljs-literal">default</span>);<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> Asynchronously send a notification to multiple handlers</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;notification&quot;&gt;</span>Notification object<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>Optional cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A task that represents the publish operation.<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>        <span class="hljs-function">Task <span class="hljs-title">Publish</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> notification, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)</span>;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> Asynchronously send a notification to multiple handlers</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;notification&quot;&gt;</span>Notification object<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>Optional cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A task that represents the publish operation.<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>        <span class="hljs-function">Task <span class="hljs-title">Publish</span>&lt;<span class="hljs-title">TNotification</span>&gt;(<span class="hljs-params">TNotification notification, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)</span><br><span class="hljs-function">            <span class="hljs-keyword">where</span> TNotification : INotification</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;上面的接口，就是整个项目最核心的接口，IMediator接口，很明确的表自己的作用，以及地位，接口里面包含四个方法:</p><ul><li>Send&lt;TResponse&gt;() &#x2F;&#x2F;异步发送一个请求到单个处理程序</li><li>Send()  &#x2F;&#x2F;异步发送一个动态调用类型的请求到单个处理程序</li><li>Publish（）  &#x2F;&#x2F;异步发送动态调用类型的请求到多个处理程序，并且不需要返回值（多个也没法给返回值）</li><li>Publish&lt;TNotification&gt;()  &#x2F;&#x2F;异步发送泛型的请求到多个处理程序，并且不需要返回值（多个也没法给返回值）<br></li></ul><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;这四个方法就是撑起我们整个类库的核心功能，就是消息传递，并且支持同步及异步的方式进行请求。<br><br>在项目的源码中，还有已经实现的MediatR类，但是开发者可以根据自己的业务以及自己的水平，自己去写一个继承接口的实现类，并且实现功能，在这里呢，我们先看人家是怎么写的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span> : <span class="hljs-title">IMediator</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ServiceFactory _serviceFactory;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ConcurrentDictionary&lt;Type, <span class="hljs-built_in">object</span>&gt; _requestHandlers = <span class="hljs-keyword">new</span> ConcurrentDictionary&lt;Type, <span class="hljs-built_in">object</span>&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> ConcurrentDictionary&lt;Type, NotificationHandlerWrapper&gt; _notificationHandlers = <span class="hljs-keyword">new</span> ConcurrentDictionary&lt;Type, NotificationHandlerWrapper&gt;();<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Initializes a new instance of the <span class="hljs-doctag">&lt;see cref=&quot;Mediator&quot;/&gt;</span> class.</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;serviceFactory&quot;&gt;</span>The single instance factory.<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mediator</span>(<span class="hljs-params">ServiceFactory serviceFactory</span>)</span><br>    &#123;<br>        _serviceFactory = serviceFactory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span>&lt;<span class="hljs-title">TResponse</span>&gt; <span class="hljs-title">Send</span>&lt;<span class="hljs-title">TResponse</span>&gt;(<span class="hljs-params">IRequest&lt;TResponse&gt; request, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (request == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(request));<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> requestType = request.GetType();<br><br>        <span class="hljs-keyword">var</span> handler = (RequestHandlerWrapper&lt;TResponse&gt;)_requestHandlers.GetOrAdd(requestType,<br>            t =&gt; Activator.CreateInstance(<span class="hljs-keyword">typeof</span>(RequestHandlerWrapperImpl&lt;,&gt;).MakeGenericType(requestType, <span class="hljs-keyword">typeof</span>(TResponse))));<br><br>        <span class="hljs-keyword">return</span> handler.Handle(request, cancellationToken, _serviceFactory);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Task&lt;<span class="hljs-built_in">object</span>?&gt; Send(<span class="hljs-built_in">object</span> request, CancellationToken cancellationToken = <span class="hljs-literal">default</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (request == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(request));<br>        &#125;<br>        <span class="hljs-keyword">var</span> requestType = request.GetType();<br>        <span class="hljs-keyword">var</span> requestInterfaceType = requestType<br>            .GetInterfaces()<br>            .FirstOrDefault(i =&gt; i.IsGenericType &amp;&amp; i.GetGenericTypeDefinition() == <span class="hljs-keyword">typeof</span>(IRequest&lt;&gt;));<br>        <span class="hljs-keyword">var</span> isValidRequest = requestInterfaceType != <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">if</span> (!isValidRequest)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;<span class="hljs-keyword">nameof</span>(request)&#125;</span> does not implement $<span class="hljs-subst">&#123;<span class="hljs-keyword">nameof</span>(IRequest)&#125;</span>&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> responseType = requestInterfaceType!.GetGenericArguments()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">var</span> handler = _requestHandlers.GetOrAdd(requestType,<br>            t =&gt; Activator.CreateInstance(<span class="hljs-keyword">typeof</span>(RequestHandlerWrapperImpl&lt;,&gt;).MakeGenericType(requestType, responseType)));<br><br>        <span class="hljs-comment">// call via dynamic dispatch to avoid calling through reflection for performance reasons</span><br>        <span class="hljs-keyword">return</span> ((RequestHandlerBase) handler).Handle(request, cancellationToken, _serviceFactory);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">Publish</span>&lt;<span class="hljs-title">TNotification</span>&gt;(<span class="hljs-params">TNotification notification, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>) <span class="hljs-keyword">where</span> TNotification : INotification</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (notification == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(notification));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> PublishNotification(notification, cancellationToken);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">Publish</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> notification, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (notification == <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentNullException(<span class="hljs-keyword">nameof</span>(notification));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (notification <span class="hljs-keyword">is</span> INotification instance)<br>        &#123;<br>            <span class="hljs-keyword">return</span> PublishNotification(instance, cancellationToken);<br>        &#125;<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentException(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;<span class="hljs-keyword">nameof</span>(notification)&#125;</span> does not implement $<span class="hljs-subst">&#123;<span class="hljs-keyword">nameof</span>(INotification)&#125;</span>&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Override in a derived class to control how the tasks are awaited. By default the implementation is a foreach and await of each handler</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;allHandlers&quot;&gt;</span>Enumerable of tasks representing invoking each notification handler<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;notification&quot;&gt;</span>The notification being published<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>The cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A task representing invoking all handlers<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PublishCore</span>(<span class="hljs-params">IEnumerable&lt;Func&lt;INotification, CancellationToken, Task&gt;&gt; allHandlers, INotification notification, CancellationToken cancellationToken</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> handler <span class="hljs-keyword">in</span> allHandlers)<br>        &#123;<br>            <span class="hljs-keyword">await</span> handler(notification, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Task <span class="hljs-title">PublishNotification</span>(<span class="hljs-params">INotification notification, CancellationToken cancellationToken = <span class="hljs-literal">default</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> notificationType = notification.GetType();<br>        <span class="hljs-keyword">var</span> handler = _notificationHandlers.GetOrAdd(notificationType,<br>            t =&gt; (NotificationHandlerWrapper)Activator.CreateInstance(<span class="hljs-keyword">typeof</span>(NotificationHandlerWrapperImpl&lt;&gt;).MakeGenericType(notificationType)));<br><br>        <span class="hljs-keyword">return</span> handler.Handle(notification, cancellationToken, _serviceFactory, PublishCore);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;我们注意到，在类的构造函数中，它注入了一个ServiceFactory，这个ServiceFactory是个什么东西，我们来看一下</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> Factory method used to resolve all services. For multiple instances, it will resolve against <span class="hljs-doctag">&lt;see cref=&quot;IEnumerable&#123;T&#125;&quot; /&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;serviceType&quot;&gt;</span>Type of service to resolve<span class="hljs-doctag">&lt;/param&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>An instance of type <span class="hljs-doctag">&lt;paramref name=&quot;serviceType&quot; /&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">object</span> <span class="hljs-title">ServiceFactory</span>(<span class="hljs-params">Type serviceType</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ServiceFactoryExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">GetInstance</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> ServiceFactory factory</span>)</span>=&gt; (T) factory(<span class="hljs-keyword">typeof</span>(T));<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">IEnumerable</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-title">GetInstances</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"><span class="hljs-keyword">this</span> ServiceFactory factory</span>)</span> <br>    &#123;<br>        Type type = <span class="hljs-keyword">typeof</span>(IEnumerable&lt;T&gt;);<br><br>        <span class="hljs-keyword">var</span> a = (IEnumerable&lt;T&gt;) factory.Invoke(<span class="hljs-keyword">typeof</span>(IEnumerable&lt;T&gt;));<br><br>        <span class="hljs-keyword">return</span> a;<br>    &#125; <br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ServiceFactory是干什么用的，这次我们看注释,我给翻译了一下：用于解析所有服务的工厂方法。对于多个实例，它将解析为IEnumerable，欸！这就很有意思了，他的意思是什么呢，他是一个工厂，通过IOC也就是依赖注入，当你使用的时候，指定一个类型，他将在IOC容器里面直接给你解析出一个或者多个实例出来，是不是很牛逼，反正我觉得很牛逼，当初这玩意我整整研究了一天才研究明白！搞清楚ServiceFactory的用法以后，我们开始一步步理清这个项目是如何实现功能的，首先我们从Send()开始,我们可以看到，当参数类传入进来以后，首先根据GetType方法得到了参数类型，然后通过反射实例化出了一个继承于RequestHandlerWrapperImpl&lt;,&gt;类型的实例,那么这个RequestHandlerWrapperImpl&lt;,&gt;又是干啥的呢？我们进去看一下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestHandlerBase</span><br>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title">Task</span>&lt;<span class="hljs-title">object</span>?&gt; <span class="hljs-title">Handle</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> request, CancellationToken cancellationToken,ServiceFactory serviceFactory</span>)</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> THandler <span class="hljs-title">GetHandler</span>&lt;<span class="hljs-title">THandler</span>&gt;(<span class="hljs-params">ServiceFactory factory</span>)</span><br>        &#123;<br>            THandler handler;<br><br>            <span class="hljs-keyword">try</span><br>            &#123;<br>                handler = factory.GetInstance&lt;THandler&gt;();<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e)<br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">$&quot;Error constructing handler for request of type <span class="hljs-subst">&#123;<span class="hljs-keyword">typeof</span>(THandler)&#125;</span>. Register your handlers with the container. See the samples in GitHub for examples.&quot;</span>, e);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (handler == <span class="hljs-literal">null</span>)<br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(<span class="hljs-string">$&quot;Handler was not found for request of type <span class="hljs-subst">&#123;<span class="hljs-keyword">typeof</span>(THandler)&#125;</span>. Register your handlers with the container. See the samples in GitHub for examples.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> handler;<br>        &#125;<br>&#125;<br><br> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestHandlerWrapper</span>&lt;<span class="hljs-title">TResponse</span>&gt; : <span class="hljs-title">RequestHandlerBase</span><br> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Task&lt;TResponse&gt; <span class="hljs-title">Handle</span>(<span class="hljs-params">IRequest&lt;TResponse&gt; request, CancellationToken cancellationToken,ServiceFactory serviceFactory</span>)</span>;<br> &#125;<br> <br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestHandlerWrapperImpl</span>&lt;<span class="hljs-title">TRequest</span>, <span class="hljs-title">TResponse</span>&gt; : <span class="hljs-title">RequestHandlerWrapper</span>&lt;<span class="hljs-title">TResponse</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-title">TRequest</span> : <span class="hljs-title">IRequest</span>&lt;<span class="hljs-title">TResponse</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task&lt;<span class="hljs-built_in">object</span>?&gt; Handle(<span class="hljs-built_in">object</span> request, CancellationToken cancellationToken, ServiceFactory serviceFactory)<br>    &#123;<br>            <span class="hljs-keyword">return</span> Handle((IRequest&lt;TResponse&gt;)request, cancellationToken, serviceFactory).ContinueWith(t =&gt;<br>            &#123;<br>                <span class="hljs-keyword">if</span> (t.IsFaulted)<br>                &#123;<br>                    ExceptionDispatchInfo.Capture(t.Exception.InnerException).Throw();<br>                &#125;<br>                    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">object</span>?)t.Result;<br>            &#125;, cancellationToken);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task&lt;TResponse&gt; <span class="hljs-title">Handle</span>(<span class="hljs-params">IRequest&lt;TResponse&gt; request, CancellationToken cancellationToken,ServiceFactory serviceFactory</span>)</span><br>    &#123;<br>            <span class="hljs-function">Task&lt;TResponse&gt; <span class="hljs-title">Handler</span>()</span> =&gt; GetHandler&lt;IRequestHandler&lt;TRequest, TResponse&gt;&gt;(serviceFactory).Handle((TRequest) request, cancellationToken);<br><br>            <span class="hljs-keyword">return</span> serviceFactory<br>                   .GetInstances&lt;IPipelineBehavior&lt;TRequest, TResponse&gt;&gt;()<br>                   .Reverse()<br>                   .Aggregate((RequestHandlerDelegate&lt;TResponse&gt;) Handler, (next, pipeline) =&gt; () =&gt; pipeline.Handle((TRequest)request, cancellationToken, next))();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;又是个典型的包装器模式，话不多说直接看实现，我们可以看到RequestHandlerWrapperImpl&lt;,&gt;类继承于RequestHandlerWrapper&lt;TRespose&gt;类，是包装器的实现类,其中类里面包含一个Handle方法,将参数以及ServiceFactory传入进来以后首先解析出继承管道的所有类,欸！！！这个时候我们回顾一下我们的问题，管道的执行顺序，嘿嘿最骚的来了,<br>我们看他下面的Reverse()这个方法，是将IEnumerable类型的元素反过来排序,这个时候你就问了，这跟顺序有啥关系？我来告诉你！！NetCore的IOC容器，不管是内置的还是AutoFac，进行注册的时候，服务进入容器的顺序就像压栈一样，先进的被压在下面，后进的在上面，调用顺序也是先进后出的顺序。所以当我们根据依赖注入反射出所有管道实现类以后，反转排序一下，是不是就跟你注册时候写的顺序一毛一样了？？？这个时候下面的Aggregate()方法，就会按照管道顺序，一个一个的执行，可以看到在Aggregate()方法，还传入了一个请求处理的委托类型Handler,这个委托类型就是管道最后所执行的我们传入的参数的处理类型，看一下Haddler的实现方法,首先是通过GetHandler&lt;THandler&gt;()方法(这个方法在RequestHandlerBase那个抽象类里面,不记得的往上翻)通过IOC获取出对应的实例出来，然后调用实例的Handle()方法进行处理。一对一消息传递的所有的流程全部走完，还有人问通知模式下如何实现的？来我告诉你。。。看源码:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NotificationHandlerWrapper</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Task <span class="hljs-title">Handle</span>(<span class="hljs-params">INotification notification, CancellationToken cancellationToken, ServiceFactory serviceFactory,Func&lt;IEnumerable&lt;Func&lt;INotification, CancellationToken, Task&gt;&gt;, INotification, CancellationToken, Task&gt; publish</span>)</span>;<br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NotificationHandlerWrapperImpl</span>&lt;<span class="hljs-title">TNotification</span>&gt; : <span class="hljs-title">NotificationHandlerWrapper</span> <span class="hljs-keyword">where</span> <span class="hljs-title">TNotification</span> : <span class="hljs-title">INotification</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> Task <span class="hljs-title">Handle</span>(<span class="hljs-params">INotification notification, CancellationToken cancellationToken, ServiceFactory serviceFactory,Func&lt;IEnumerable&lt;Func&lt;INotification, CancellationToken, Task&gt;&gt;, INotification, CancellationToken, Task&gt; publish</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">var</span> handlers = serviceFactory.GetInstances&lt;INotificationHandler&lt;TNotification&gt;&gt;()<br>                                     .Select(x =&gt; <span class="hljs-keyword">new</span> Func&lt;INotification, CancellationToken, Task&gt;((theNotification, theToken) =&gt; x.Handle((TNotification)theNotification, theToken)));<br><br>        <span class="hljs-keyword">return</span> publish(handlers, notification, cancellationToken);<br>    &#125;<br>&#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> Override in a derived class to control how the tasks are awaited. By default the implementation is a foreach and await of each handler</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;allHandlers&quot;&gt;</span>Enumerable of tasks representing invoking each notification handler<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;notification&quot;&gt;</span>The notification being published<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;cancellationToken&quot;&gt;</span>The cancellation token<span class="hljs-doctag">&lt;/param&gt;</span></span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span>A task representing invoking all handlers<span class="hljs-doctag">&lt;/returns&gt;</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PublishCore</span>(<span class="hljs-params">IEnumerable&lt;Func&lt;INotification, CancellationToken, Task&gt;&gt; allHandlers, INotification notification, CancellationToken cancellationToken</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> handler <span class="hljs-keyword">in</span> allHandlers)<br>        &#123;<br>            <span class="hljs-keyword">await</span> handler(notification, cancellationToken).ConfigureAwait(<span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br><br><br></code></pre></td></tr></table></figure><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看到了吧，除了没有走管道，几乎一模一样,除了最后用了个publish();这个publish()就是将查出来的实现类循环执行一遍。。没了！！</p><p>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;好了，至此整个项目完全梳理完了，估计仔仔细细看一遍，不说能帮你完全了解吧，咋说也能在你看源码的时候帮你一点。。。</p><p><img src="https://img-blog.csdnimg.cn/20200715192157204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NBUEZfc2t5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200715192244487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NBUEZfc2t5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>事件总线</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MediatR</tag>
      
      <tag>EventBus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rabbitmq学习笔记</title>
    <link href="/2021/08/23/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Rabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/23/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Rabbitmq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Rabbitmq学习笔记"><a href="#Rabbitmq学习笔记" class="headerlink" title="Rabbitmq学习笔记"></a>Rabbitmq学习笔记</h1><h2 id="零、什么是消息队列"><a href="#零、什么是消息队列" class="headerlink" title="零、什么是消息队列"></a>零、什么是消息队列</h2><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;在微服务或者分布式系统中，两个或者多个服务之间通信或者一个服务发出消息需要通知给多个服务处理的时候，消息队列是一个很好的解决方案。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;AMQP : Advanced Message Queuing Protocol 高级消息队列协议，是应用层协议的一个开放标准，为面向消息中间件设计。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;何为消息中间件：消息中间件就是用于解决多个服务或者组件之间通信但是各服务之间却不需要知晓发送消息和接收消息的是谁，这样也做到了服务和模块之间的解耦。</p><h2 id="一、Rabbitmq又是个啥？"><a href="#一、Rabbitmq又是个啥？" class="headerlink" title="一、Rabbitmq又是个啥？"></a>一、Rabbitmq又是个啥？</h2><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;RabbitMq是一个消息代理中间件，用于接收和转发消息，按照官方文档的解释，可以把兔子看成一个邮局，它做着和邮局一样的事情。就是接收到消息发送方发出的消息，然后根据收件信息（路由名称）将信息推送给消费者；</p><h2 id="二、Rabbitmq的主要核心概念"><a href="#二、Rabbitmq的主要核心概念" class="headerlink" title="二、Rabbitmq的主要核心概念"></a>二、Rabbitmq的主要核心概念</h2><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp; <H3>Rabbitmq具有以下几个核心概念</H3></p><h5 id="0、消息生产者（producer）：顾名思义，消息生产者就是产生消息并且将消息发送出来的一方，"><a href="#0、消息生产者（producer）：顾名思义，消息生产者就是产生消息并且将消息发送出来的一方，" class="headerlink" title="0、消息生产者（producer）：顾名思义，消息生产者就是产生消息并且将消息发送出来的一方，"></a>0、消息生产者（producer）：顾名思义，消息生产者就是产生消息并且将消息发送出来的一方，</h5><h5 id="1、消息接收者（消费者）（consumer）：接收消息并消费的一方"><a href="#1、消息接收者（消费者）（consumer）：接收消息并消费的一方" class="headerlink" title="1、消息接收者（消费者）（consumer）：接收消息并消费的一方"></a>1、消息接收者（消费者）（consumer）：接收消息并消费的一方</h5><h5 id="2、队列（Queue）-队列，这里的队列是RabbitMq的内部对象，用于存储消息，RabbitMq的消息都存储在Queue中，然后推送给消费者"><a href="#2、队列（Queue）-队列，这里的队列是RabbitMq的内部对象，用于存储消息，RabbitMq的消息都存储在Queue中，然后推送给消费者" class="headerlink" title="2、队列（Queue）:队列，这里的队列是RabbitMq的内部对象，用于存储消息，RabbitMq的消息都存储在Queue中，然后推送给消费者"></a>2、队列（Queue）:队列，这里的队列是RabbitMq的内部对象，用于存储消息，RabbitMq的消息都存储在Queue中，然后推送给消费者</h5><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp; <H5>三者关系如下图</H5><br><img src="https://img-blog.csdnimg.cn/img_convert/d7fcbb676e06e9e9e26581650996b35b.png" alt="图"></p><h5 id="3、信道（Channel）：用于客户端与RabbitMq服务器连接通信的通道，由于RabbitMq服务与客户端之间的连接是需要一条基于TCP连接的长连接，所以Channel是建立在Connection上的一条虚拟连接，RabbitMq所需要处理的每条消息以及指令都需要通过Channel完成，每个Channel都会被指派一个唯一的ID-之所以建立并使用信道，是因为为了减少创建Connection-TCP连接-。"><a href="#3、信道（Channel）：用于客户端与RabbitMq服务器连接通信的通道，由于RabbitMq服务与客户端之间的连接是需要一条基于TCP连接的长连接，所以Channel是建立在Connection上的一条虚拟连接，RabbitMq所需要处理的每条消息以及指令都需要通过Channel完成，每个Channel都会被指派一个唯一的ID-之所以建立并使用信道，是因为为了减少创建Connection-TCP连接-。" class="headerlink" title="3、信道（Channel）：用于客户端与RabbitMq服务器连接通信的通道，由于RabbitMq服务与客户端之间的连接是需要一条基于TCP连接的长连接，所以Channel是建立在Connection上的一条虚拟连接，RabbitMq所需要处理的每条消息以及指令都需要通过Channel完成，每个Channel都会被指派一个唯一的ID,之所以建立并使用信道，是因为为了减少创建Connection(TCP连接)。"></a>3、信道（Channel）：用于客户端与RabbitMq服务器连接通信的通道，由于RabbitMq服务与客户端之间的连接是需要一条基于TCP连接的长连接，所以Channel是建立在Connection上的一条虚拟连接，RabbitMq所需要处理的每条消息以及指令都需要通过Channel完成，每个Channel都会被指派一个唯一的ID,之所以建立并使用信道，是因为为了减少创建Connection(TCP连接)。</h5><h5 id="4、交换机-Exchange-和BindingKey-绑定键-绑定键是用于将交换机与队列建立绑定关系所实现的。消息的接受以及发送则需要通过交换机来根据交换机规则进行消息的推送以及处理"><a href="#4、交换机-Exchange-和BindingKey-绑定键-绑定键是用于将交换机与队列建立绑定关系所实现的。消息的接受以及发送则需要通过交换机来根据交换机规则进行消息的推送以及处理" class="headerlink" title="4、交换机(Exchange)和BindingKey(绑定键):绑定键是用于将交换机与队列建立绑定关系所实现的。消息的接受以及发送则需要通过交换机来根据交换机规则进行消息的推送以及处理"></a>4、交换机(Exchange)和BindingKey(绑定键):绑定键是用于将交换机与队列建立绑定关系所实现的。消息的接受以及发送则需要通过交换机来根据交换机规则进行消息的推送以及处理</h5><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp; <H6>交换机的几种类型</H6></p><blockquote><h6 id="fanout-扇形交换机，全方位无差别轰炸，只要是绑定在交换机的消费者均可收到消息，就是这么豪横。"><a href="#fanout-扇形交换机，全方位无差别轰炸，只要是绑定在交换机的消费者均可收到消息，就是这么豪横。" class="headerlink" title="fanout: 扇形交换机，全方位无差别轰炸，只要是绑定在交换机的消费者均可收到消息，就是这么豪横。"></a>fanout: 扇形交换机，全方位无差别轰炸，只要是绑定在交换机的消费者均可收到消息，就是这么豪横。</h6><h6 id="direct-直连交换机，精准打击，这里是精准找到与消息指定的RoutingKey完全匹配的消费者们-们：这里的消费者可以是多个RoutingKey匹配的消费者-进行推送。形象点如果把性别看作RoutingKey，厕所看作交换机，每个进厕所的人看作队列，而“向前一小步，文明一大步”看作消息的话，那么只有RoutingKey是男的队列（人们）才可以接收到这则消息。"><a href="#direct-直连交换机，精准打击，这里是精准找到与消息指定的RoutingKey完全匹配的消费者们-们：这里的消费者可以是多个RoutingKey匹配的消费者-进行推送。形象点如果把性别看作RoutingKey，厕所看作交换机，每个进厕所的人看作队列，而“向前一小步，文明一大步”看作消息的话，那么只有RoutingKey是男的队列（人们）才可以接收到这则消息。" class="headerlink" title="direct: 直连交换机，精准打击，这里是精准找到与消息指定的RoutingKey完全匹配的消费者们(们：这里的消费者可以是多个RoutingKey匹配的消费者)进行推送。形象点如果把性别看作RoutingKey，厕所看作交换机，每个进厕所的人看作队列，而“向前一小步，文明一大步”看作消息的话，那么只有RoutingKey是男的队列（人们）才可以接收到这则消息。"></a>direct: 直连交换机，精准打击，这里是精准找到与消息指定的RoutingKey完全匹配的消费者们(们：这里的消费者可以是多个RoutingKey匹配的消费者)进行推送。形象点如果把性别看作RoutingKey，厕所看作交换机，每个进厕所的人看作队列，而“向前一小步，文明一大步”看作消息的话，那么只有RoutingKey是男的队列（人们）才可以接收到这则消息。</h6><h6 id="topic：规则交换机，就是该交换机下所有绑定的路由，只要符合消息的RoutingKey规则，则就都可以接收到消息的推送如：我发送的RoutingKey是-sky-nt-lueluelue-则，消息队列绑定的RoutingKey为：-gt-sky-和-nt-以及-lueluelue等一次类推的所有队列都可以接收到消息推送。"><a href="#topic：规则交换机，就是该交换机下所有绑定的路由，只要符合消息的RoutingKey规则，则就都可以接收到消息的推送如：我发送的RoutingKey是-sky-nt-lueluelue-则，消息队列绑定的RoutingKey为：-gt-sky-和-nt-以及-lueluelue等一次类推的所有队列都可以接收到消息推送。" class="headerlink" title="topic：规则交换机，就是该交换机下所有绑定的路由，只要符合消息的RoutingKey规则，则就都可以接收到消息的推送如：我发送的RoutingKey是 sky.nt.lueluelue 则，消息队列绑定的RoutingKey为：&gt;sky.. 和 .nt. 以及 ..lueluelue等一次类推的所有队列都可以接收到消息推送。"></a>topic：规则交换机，就是该交换机下所有绑定的路由，只要符合消息的RoutingKey规则，则就都可以接收到消息的推送如：我发送的RoutingKey是 sky.nt.lueluelue 则，消息队列绑定的RoutingKey为：&gt;sky.<em>.</em> 和 <em>.nt.</em> 以及 <em>.</em>.lueluelue等一次类推的所有队列都可以接收到消息推送。</h6><h6 id="headers：头信息交换机，这个交换机就比较骚了。为啥呢？因为这个交换机不通过RoutingKey来匹配。他是通过消息的Header-头信息-中的某一属性来进行匹配的，当队列与交换机进行绑定的时候，指定一组-gt-键值对；当发送消息的时候在头信息里面放入这个键值对，则就会接收到消息，反之这接收不到。不过一般都没啥人用，属于核弹级别，看起来很吊，就是没人敢用或者说没有场景来用。"><a href="#headers：头信息交换机，这个交换机就比较骚了。为啥呢？因为这个交换机不通过RoutingKey来匹配。他是通过消息的Header-头信息-中的某一属性来进行匹配的，当队列与交换机进行绑定的时候，指定一组-gt-键值对；当发送消息的时候在头信息里面放入这个键值对，则就会接收到消息，反之这接收不到。不过一般都没啥人用，属于核弹级别，看起来很吊，就是没人敢用或者说没有场景来用。" class="headerlink" title="headers：头信息交换机，这个交换机就比较骚了。为啥呢？因为这个交换机不通过RoutingKey来匹配。他是通过消息的Header(头信息)中的某一属性来进行匹配的，当队列与交换机进行绑定的时候，指定一组&gt; 键值对；当发送消息的时候在头信息里面放入这个键值对，则就会接收到消息，反之这接收不到。不过一般都没啥人用，属于核弹级别，看起来很吊，就是没人敢用或者说没有场景来用。"></a>headers：头信息交换机，这个交换机就比较骚了。为啥呢？因为这个交换机不通过RoutingKey来匹配。他是通过消息的Header(头信息)中的某一属性来进行匹配的，当队列与交换机进行绑定的时候，指定一组&gt; 键值对；当发送消息的时候在头信息里面放入这个键值对，则就会接收到消息，反之这接收不到。不过一般都没啥人用，属于核弹级别，看起来很吊，就是没人敢用或者说没有场景来用。</h6></blockquote><h5 id="5、消息的持久化（Message-acknowledgment）：为了避免由于服务器宕机而导致的消息丢失，RabbitMq实现了消息的持久化功能，所谓的消息持久化就是将Rabbitmq服务器内存里面的数据如：交换机、队列、消息存储在硬盘中，以防服务器宕机或者损坏所造成的数据丢失。"><a href="#5、消息的持久化（Message-acknowledgment）：为了避免由于服务器宕机而导致的消息丢失，RabbitMq实现了消息的持久化功能，所谓的消息持久化就是将Rabbitmq服务器内存里面的数据如：交换机、队列、消息存储在硬盘中，以防服务器宕机或者损坏所造成的数据丢失。" class="headerlink" title="5、消息的持久化（Message acknowledgment）：为了避免由于服务器宕机而导致的消息丢失，RabbitMq实现了消息的持久化功能，所谓的消息持久化就是将Rabbitmq服务器内存里面的数据如：交换机、队列、消息存储在硬盘中，以防服务器宕机或者损坏所造成的数据丢失。"></a>5、消息的持久化（Message acknowledgment）：为了避免由于服务器宕机而导致的消息丢失，RabbitMq实现了消息的持久化功能，所谓的消息持久化就是将Rabbitmq服务器内存里面的数据如：交换机、队列、消息存储在硬盘中，以防服务器宕机或者损坏所造成的数据丢失。</h5><blockquote><p>Rabbitmq 持久化方式分为如下几种：</p><h6 id="0、交换机（Exchange）持久化：在创建交换机的需要指定durable为True表示开启持久化。"><a href="#0、交换机（Exchange）持久化：在创建交换机的需要指定durable为True表示开启持久化。" class="headerlink" title="0、交换机（Exchange）持久化：在创建交换机的需要指定durable为True表示开启持久化。"></a>0、交换机（Exchange）持久化：在创建交换机的需要指定<code>durable</code>为<code>True</code>表示开启持久化。</h6><h6 id="1、队列（Queue）持久化：在创建队列时指定durable为True即可。"><a href="#1、队列（Queue）持久化：在创建队列时指定durable为True即可。" class="headerlink" title="1、队列（Queue）持久化：在创建队列时指定durable为True即可。"></a>1、队列（Queue）持久化：在创建队列时指定<code>durable</code>为<code>True</code>即可。</h6><h6 id="2、消息（Message）的持久化：如果需要开启消息的持久化，则需要将消息的deliveryMode设置成为2即代表消息持久化。但是由于消息会被写入到硬盘，所以对Rabbitmq的性能也是会影响的，而且消息持久化并不能保证消息百分百的不丢失，万一你往磁盘写的时候断电了，或者服务器炸了，消息还是会丢失的。"><a href="#2、消息（Message）的持久化：如果需要开启消息的持久化，则需要将消息的deliveryMode设置成为2即代表消息持久化。但是由于消息会被写入到硬盘，所以对Rabbitmq的性能也是会影响的，而且消息持久化并不能保证消息百分百的不丢失，万一你往磁盘写的时候断电了，或者服务器炸了，消息还是会丢失的。" class="headerlink" title="2、消息（Message）的持久化：如果需要开启消息的持久化，则需要将消息的deliveryMode设置成为2即代表消息持久化。但是由于消息会被写入到硬盘，所以对Rabbitmq的性能也是会影响的，而且消息持久化并不能保证消息百分百的不丢失，万一你往磁盘写的时候断电了，或者服务器炸了，消息还是会丢失的。"></a>2、消息（Message）的持久化：如果需要开启消息的持久化，则需要将消息的<code>deliveryMode</code>设置成为2即代表消息持久化。但是由于消息会被写入到硬盘，所以对Rabbitmq的性能也是会影响的，而且消息持久化并不能保证消息百分百的不丢失，万一你往磁盘写的时候断电了，或者服务器炸了，消息还是会丢失的。</h6><h6 id="注：持久化是各管各的，持久化了交换机就只能持久化交换机，交换机里面的队列还是会丢失的，所以这俩要开就都开。至于消息的话，其实可以考虑存入缓存或者数据库等地方实现持久化"><a href="#注：持久化是各管各的，持久化了交换机就只能持久化交换机，交换机里面的队列还是会丢失的，所以这俩要开就都开。至于消息的话，其实可以考虑存入缓存或者数据库等地方实现持久化" class="headerlink" title="(注：持久化是各管各的，持久化了交换机就只能持久化交换机，交换机里面的队列还是会丢失的，所以这俩要开就都开。至于消息的话，其实可以考虑存入缓存或者数据库等地方实现持久化)"></a>(注：持久化是各管各的，持久化了交换机就只能持久化交换机，交换机里面的队列还是会丢失的，所以这俩要开就都开。至于消息的话，其实可以考虑存入缓存或者数据库等地方实现持久化)</h6></blockquote><h4 id="6、RPC（RPC）：消息的回调，因为消息队列是基于异步的消息处理，并且根据消息队列特性，发送者并不知道消费者具体是谁，更别说是否消费成功了，但是在某些时候或者应用场景上面，我们是需要判断这条消息发送出去后是否处理成功了，这个时候我们就用上了Rabbitmq的RPC机制了"><a href="#6、RPC（RPC）：消息的回调，因为消息队列是基于异步的消息处理，并且根据消息队列特性，发送者并不知道消费者具体是谁，更别说是否消费成功了，但是在某些时候或者应用场景上面，我们是需要判断这条消息发送出去后是否处理成功了，这个时候我们就用上了Rabbitmq的RPC机制了" class="headerlink" title="6、RPC（RPC）：消息的回调，因为消息队列是基于异步的消息处理，并且根据消息队列特性，发送者并不知道消费者具体是谁，更别说是否消费成功了，但是在某些时候或者应用场景上面，我们是需要判断这条消息发送出去后是否处理成功了，这个时候我们就用上了Rabbitmq的RPC机制了"></a>6、RPC（RPC）：消息的回调，因为消息队列是基于异步的消息处理，并且根据消息队列特性，发送者并不知道消费者具体是谁，更别说是否消费成功了，但是在某些时候或者应用场景上面，我们是需要判断这条消息发送出去后是否处理成功了，这个时候我们就用上了Rabbitmq的RPC机制了</h4><blockquote><p>Rabbitmq RPC具体实现方法：</p><h6 id="在消息的属性（MessageProperties）中，设置两个值："><a href="#在消息的属性（MessageProperties）中，设置两个值：" class="headerlink" title="在消息的属性（MessageProperties）中，设置两个值："></a>在消息的属性（MessageProperties）中，设置两个值：</h6><h6 id="0、replyTo-这里写需要回调的路由名称，在消息在处理完成以后将会发送消息队列到这个指定的消息中。"><a href="#0、replyTo-这里写需要回调的路由名称，在消息在处理完成以后将会发送消息队列到这个指定的消息中。" class="headerlink" title="0、replyTo:这里写需要回调的路由名称，在消息在处理完成以后将会发送消息队列到这个指定的消息中。"></a>0、replyTo:这里写需要回调的路由名称，在消息在处理完成以后将会发送消息队列到这个指定的消息中。</h6><h6 id="1、CorrelationId-当前请求的唯一标识，用于区分消息。"><a href="#1、CorrelationId-当前请求的唯一标识，用于区分消息。" class="headerlink" title="1、CorrelationId:当前请求的唯一标识，用于区分消息。"></a>1、CorrelationId:当前请求的唯一标识，用于区分消息。</h6></blockquote><h2 id="三、死信队列"><a href="#三、死信队列" class="headerlink" title="三、死信队列"></a>三、死信队列</h2><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Rabbitmq如果出现长时间没有人消费的、被拒绝接收的，队列达到最大长度以后进入队列的，都被称为死信，而死信所归往的地方就被称为死信队列，死信队列与其他队列有何不同呢？并没有什么不同，只不过消息变成死信后会经由死信交换机发送到死信队列上面，然后由死信队列的消费者去处理这些队列。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;那么“死信”被丢到死信队列中后，会发生什么变化呢？如果队列配置了参数 x-dead-letter-routing-key 的话，“死信”的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;举个栗子：</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;如果原有消息的路由key是testA，被发送到业务Exchage中，然后被投递到业务队列QueueA中，如果该队列没有配置参数x-dead-letter-routing-key，则该消息成为死信后，将保留原有的路由keytestA，如果配置了该参数，并且值设置为testB，那么该消息成为死信后，路由key将会被替换为testB，然后被抛到死信交换机中。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;另外，由于被抛到了死信交换机，所以消息的Exchange Name也会被替换为死信交换机的名称。</p><h2 id="四、参考链接："><a href="#四、参考链接：" class="headerlink" title="四、参考链接："></a>四、参考链接：</h2><blockquote><p>0、 <a href="https://www.cnblogs.com/williamjie/p/9481774.html">https://www.cnblogs.com/williamjie/p/9481774.html</a><br>1、<a href="https://www.jianshu.com/p/5c2d8af2c78e">https://www.jianshu.com/p/5c2d8af2c78e</a><br>2、<a href="https://www.cnblogs.com/eleven24/p/10326718.html">https://www.cnblogs.com/eleven24/p/10326718.html</a><br>3、<a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a><br>4、<a href="https://juejin.cn/post/6844904039193280526">https://juejin.cn/post/6844904039193280526</a><br>5、<a href="https://www.cnblogs.com/mfrank/p/11184929.html">https://www.cnblogs.com/mfrank/p/11184929.html</a><br>6、<a href="https://www.cnblogs.com/williamjie/p/9481774.html">https://www.cnblogs.com/williamjie/p/9481774.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dotnetCore微服务API网关-Ocelot学习笔记（一、API网关介绍及Ocelot介绍和配置）</title>
    <link href="/2021/07/27/%E7%BD%91%E5%85%B3/dotnetCore%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3-Ocelot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E3%80%81API%E7%BD%91%E5%85%B3%E4%BB%8B%E7%BB%8D%E5%8F%8AOcelot%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%89/"/>
    <url>/2021/07/27/%E7%BD%91%E5%85%B3/dotnetCore%E5%BE%AE%E6%9C%8D%E5%8A%A1API%E7%BD%91%E5%85%B3-Ocelot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E3%80%81API%E7%BD%91%E5%85%B3%E4%BB%8B%E7%BB%8D%E5%8F%8AOcelot%E4%BB%8B%E7%BB%8D%E5%92%8C%E9%85%8D%E7%BD%AE%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="dotnetCore微服务API网关-Ocelot学习笔记（一、API网关介绍及Ocelot介绍和配置）"><a href="#dotnetCore微服务API网关-Ocelot学习笔记（一、API网关介绍及Ocelot介绍和配置）" class="headerlink" title="dotnetCore微服务API网关-Ocelot学习笔记（一、API网关介绍及Ocelot介绍和配置）"></a>dotnetCore微服务API网关-Ocelot学习笔记（一、API网关介绍及Ocelot介绍和配置）</h1><h2 id="零、为啥写这个"><a href="#零、为啥写这个" class="headerlink" title="零、为啥写这个"></a>零、为啥写这个</h2><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;说实话工作用了两年多的微服务了，自己却连工作所用的微服务API网关都没有深入的了解和学习过，只存在于会改会写的阶段，一直觉得特别惭愧，所以自己一直想深入的了解和学习一下，然后近期不是工作不是很忙，就想着研究一下，结果去找网上的文档和博客，这里容我骂句脏话（此处并不针对谁，不服你憋着），找了十篇，结果八篇内容都差不多，全都是把官方文档的架构图拿来翻译一下，然后就是按照官方示例贴代码，让人整个看下来还是一脸懵逼，不懂还是不懂，而且找来找去就那么几篇，也不知道是这网关没人用,还是说DotNet生态不好。没办法，只能自己扒拉源码，然后把自己的理解写下来，希望对其他人也能有一些帮助。当然，要是没帮助那算了。我也不是大佬，只能理解到这种程度，或许以后有新的理解了我会把这篇文档重新写一遍，大家共同学习进步吧。</p><h2 id="一、关于什么是API网关"><a href="#一、关于什么是API网关" class="headerlink" title="一、关于什么是API网关"></a>一、关于什么是API网关</h2><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;API网关通常是指。。。我特么也不知道怎么讲(lll￢ω￢)，通俗点大白话讲，网关在我眼里其实就是某个微服务系统的统一入口，所有对该系统的请求访问都需要通过网关转发，从而不需要分别去请求那些各个独立的服务，而且网关还支持协议转换，外部客户端可以使用Http进行请求，到了网关内部可以转换为RPC去请求具体的服务接口。</p><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;要是还不理解的话，给你个场景，自己体会，你有一个非常喜欢的人，然后终于某天你鼓起勇气想当面对她表白，于是你买了一束花准备送给她，当你骑着你心爱的小摩托兴奋无比的到了姑娘家小区门口的时候，突然发现小区西门立着一位带着红箍老大爷拦住了你的脚步，大爷看到你问：“小伙子<strong>找谁啊，要干啥</strong> ”。然后你跟大爷说：“我要去找<strong>几号楼几号楼的XX</strong>，我是她朋友，来找她<strong>送</strong>点东西”，然后大爷掏出一个神奇的小本本让你把身份证及电话号码登记，然后扫码量体温，等你做好以后，大爷拿起门岗的电话，拨通她们家的电话，此时电话一直<strong>没人接</strong>，然后大爷告诉你，家没人，你改天再来吧！然后无情地把你赶走，但是你不死心，你又去到了小区的北门，结果发现<strong>北门锁了</strong>！倔强的你又无奈的去了小区的东门，这次经过一系列的登记和沟通后，东门的大爷说，因为疫情原因我不能让你进去，不过你可以把东西给我我给你转送过去，然后你把鲜花交给大爷，大爷骑着小电电去帮你送，一会大爷回来了，带回来一封<strong>信</strong>，你拆看信上写着你是个好人！但我们不合适,然后你还不死心，天天去送，天天得到的都是同一封信，最后那姑娘直接把信放在了<strong>大爷那</strong>，你一去大爷直接从<strong>抽屉</strong>里拿出了信。</p><blockquote><p>综上所述，我们来梳理下：<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;首先我们把小区看成是一个微服务的系统，小区内的每栋楼都一&gt;个独立的服务。而门户就可以看成服务的接口。<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;而此时，我们的小区大爷就可以看作是这个系统的网关<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;通过上面我们知道网关可以做到：<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;0、入口统一：网关不在乎你从什么地方来，你是手机客户端也好，PC客户端或者网页客户端也罢，统统都要走网关。<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;1、超时断开：当你请求长时间没有回应的时候，网关会断开请求<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;2、路由转发：网关要知道你访问的系统内部地址是哪里(路由地址Route)后并帮你进行转发，把请求转发到具体的服务接口上<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;3、请求方式限制：要知道你的目的是干什么（POST&#x2F;GET&#x2F;等..）<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;4、认证鉴权：登记身份（认证、鉴权）<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;5、负载均衡：就算一个门锁了（网关服务坏掉了），也有其他门（网关）可以处理，不会出现一个网关坏掉整个系统瘫痪的情况出现。<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;6、协议转换：当你骑着心爱的小摩托（Http请求）来的时候，网关转发的时候可能转换成另一种请求协议，如：GRPC或其他RPC协议（Ocelot好像只支持Http，很尴尬）<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;7、缓存机制：当你请求频繁并且获取的数据都是一样的时候，其实可以把数据放到网关层面缓存起来，这样可以减少系统的压力<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;网关还可以做的事情<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;1、服务降级:当你请求某项资源用时较长或者高峰时，网关会将你的请求降级到你早前设置好的降级策略中，保证接口返回可用的部分数据或者资源。<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;2、削峰&#x2F;限流:当你的请求过多的时候，容易对服务器造成非常大压力，比如秒杀或者某些需要抢购的活动时，这个时候我们就需要把请求进行削峰&#x2F;限流，提示用户排队等候。（讲到这里，我想到我之前面试一家公司的时候，面试我的那位大哥问了我很经典的搭建秒杀服务的问题，问我如何保证系统稳定和库存，当时对网关不甚了解，虽然讲到降级削峰，也是在接口级别做的，后来面试结束后我很不要脸的问了一下大哥如何处理秒杀的情况，这位大哥给我说了一句：“能在前面做的事情，你为啥非要放在后端做？你这不是给服务器增加压力嘛,削峰和限流是没错，但是我们可以在网关级别进行削峰和限流，甚至一些不重要的数据也可以缓存在网关级别。自此我就记住了网关的这两个功能。直到现在这位大哥还在我微信列表里面，本来想着遇到问题的时候请教一番，但是自始至终不敢打搅人家 －_－b”）<br><br>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;3、网关熔断：当网关检测到某个请求经常超时的时候，就会直接把请求熔断掉。</p></blockquote><h2 id="二、OcelotAPI网关介绍及配置方法："><a href="#二、OcelotAPI网关介绍及配置方法：" class="headerlink" title="二、OcelotAPI网关介绍及配置方法："></a>二、OcelotAPI网关介绍及配置方法：</h2><p>接下来是官方文档原话：</p><blockquote><p>Ocelot is aimed at people using .NET running a micro services &#x2F; service orientated architecture that need a unified point of entry into their system.</p><p>In particular I want easy integration with IdentityServer reference and bearer tokens.</p><p>Ocelot is a bunch of middlewares in a specific order.</p><p>Ocelot manipulates the HttpRequest object into a state specified by its configuration until it reaches a request builder middleware where it creates a HttpRequestMessage object which is used to make a request to a downstream service. The middleware that makes the request is the last thing in the Ocelot pipeline. It does not call the next middleware. There is a piece of middleware that maps the HttpResponseMessage onto the HttpResponse object and that is returned to the client. That is basically it with a bunch of other features.</p></blockquote><p>翻译(大概就这意思，我当初上学的时候去参加四级考试，并且写满了卷子，却得了0分！！所以别指望我的英语水平。)：</p><blockquote><p>Ocelot的目标用户是，使用.Net开发的微服务&#x2F;面向服务的体系结构所需要的一个统一入口站点</p><p>我特别希望能够轻松地对IdentityServer进行引用和承载令牌集成。</p><p>Ocelot 是一群（一堆？）由特性顺序组成的中间件。</p><p>Ocelot操纵HttpRequest对象进入到一个请求构建器中并设置为由其所配置的状态，在那里他创建了一个HttpRequestMessage对象，该对象用于向下游服务发出请求，发出请求的的这个中间件是Ocelot请求管道中最后一个中间件,他并不没有下一个中间件可以调用，但是会有一个中间件将HttpResponseMessage映射给HttpResponse对象，用以返回给客户端。这就是他的基本特性了。</p></blockquote><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><pre><code class="hljs">在使用之前，首先要了解网关项目所需的结构和文件。0、网关项目需要使用Asp.Net Core项目，也就是我们说的Web项目（控制台也行，只不过我嫌麻烦）1、网关的路由规则均有ocelot.json结构的json文件进行控制，这点跟平常项目的appsettings.json用法一样，并且支持中间添加环境变量如：ocelot.Debug.json，来区分不同环境变量下的网关项目规则。接下来开始一步步操作：首先,创建一个ASP.Net Core项目,我这里选择的是一个空项目，这里就不放图了，然后选择SDK，我用的是3.1的，Net5也行，主要是我还没了解完5，项目创建完以后，使用Nuget包，引用官方的包，命令就不敲了，在我这别想着复制，自己去搜吧。包名：Ocelot。然后开始配置启动类吧(Program)：</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/1889a09b5f8c09e25b35a73e698dab6b.png" alt="代码"></p><pre><code class="hljs">因为在Ocelot中路由规则等也是通过配置文件所配置的，所以配置方法和appsettings.json的方法一样，直接通过ConfigureAppConfiguration方法来将配置添加到主机的全局配置中。就像图上写的一样，手动指定Json文件，只要确保Json文件存在就可以了。而第二种就简单多了，直接使用Iconfiguraton拓展方法，调用AddOcelot(this IConfigurationBuilder builder,IWebHostEnvironment env)方法，这样的话Ocelot会在内部先查找“ocelot.json” 和“ocelot.global.json” 文件，然后查找根据环境变量匹配出对应环境变量的文件名，最后通过读取文件等一系列操作，将各个不同文件的规则全部合并到一个文件里面去。emmmm...不得不说，这个操作特别骚。（下图是源码）</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/6db04ec3103ba816332acd1675ae5ee9.png" alt="代码"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/37f91d87c6a277816ee92e24997075d8.png" alt="代码"></p><pre><code class="hljs">不过这里要说一下，在16.0.1这个版本的时候，AddOcelotBaseUrl()这个方法已经被标记过时了。此时支持的是在Json文件里面去设置基本URL：Please set BaseUrl in ocelot.json GlobalConfiguration.BaseUrl</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/13cd6cda98e0ddc4647d80fd8180b304.png" alt="代码"><br>    在上面配置文件配置之后，我们还需要在主机的Config里面去添加一下中间件管道，此时我们的网关算是集成成功了！不过你以为这就完了？图样！我们还没有去配置规则</p><h2 id="三、OcelotAPI网关路由规则文件："><a href="#三、OcelotAPI网关路由规则文件：" class="headerlink" title="三、OcelotAPI网关路由规则文件："></a>三、OcelotAPI网关路由规则文件：</h2><p>&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;如上所说，我们网关路由规则，使用的是Ocelot.json文件进行配置，那么这个规则都可以配置什么呢？他又是如何进行控制的呢？看下图：<br><img src="https://img-blog.csdnimg.cn/img_convert/ed2990ec70dd5f1e5796467d2a121fde.png" alt="代码"><br><img src="https://img-blog.csdnimg.cn/img_convert/ae8eaf99e6b00511aeac309bfa309e90.png" alt="代码"><br>    这是官方文档提供的配置示例，第一张图呢，是整个Json的结构，第一个字段呢，就是我们需要配置的路由规则，这是个数组类型，为的就是让我们配置多个服务的路由规则 <del>（废话）</del> 然后第二张图呢，就是路由的所有规则了，字段太多我就不一一介绍了，反正你记住 Down开头的一般都是配置下游服务的规则，比如下游服务的路径模板，下游服务以允许的HTTP方法，下游服务的HTTP版本和主机地址及端口之类的东西。Up开头的呢，一般都是上游主机服务一些规则。<br>    具体字段后面单开篇幅介绍好了。现在只介绍一下这些个字段，然后我们就会有一个问题，这些个字段是怎么去控制程序执行的呢？<br>    <img src="https://img-blog.csdnimg.cn/img_convert/38ba5cbec126c1f9522cc671aa02ec80.png" alt="代码"><br>    <img src="https://img-blog.csdnimg.cn/img_convert/98da378abaaa45bb5403dcb3f4d9c354.png" alt="代码"><br>    <img src="https://img-blog.csdnimg.cn/img_convert/eea44a1a094cee37dcab35fae6ea1d20.png" alt="代码"><br>    看一下注册服务时候调用的AddOcelot()函数，我们可以看出，他在方法里先是获取了项目的全局配置，然后实例化了一个OcelotBuilder类，并将配置传了进去，当我点击去看之后，我惊呆了，我特么第一次见这么长的构造函数，不过不要紧，下面全是依赖注入的东西，我们先放一边，直接看上面那一段的操作。通过注册TOptions配置实例绑定的方法，Ocelot将配置文件绑定到了一个FileConfiguration类中，点开这个类你会发现，这里面则全都是我们Json文件配置的东西，而通过配置的绑定，我们所指定的规则，则全都会赋值到这个类里面，并且在下面使之通过依赖注入注入到根容器中，以待使用的时候可以控制。</p><h2 id="四、结束语："><a href="#四、结束语：" class="headerlink" title="四、结束语："></a>四、结束语：</h2><pre><code class="hljs">时间不早了，媳妇催我睡觉了，剩下的下章在讲。拜拜各位。早睡早起身体好</code></pre>]]></content>
    
    
    <categories>
      
      <category>NetCore</category>
      
      <category>微服务</category>
      
      <category>网关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NetCore</tag>
      
      <tag>网关</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
